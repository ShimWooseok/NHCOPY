//Alopex UI Version. 2.1.39
//generated at 2014-02-14 10:08 AM, by SKCCADMIN.
/**
***************************** Change Log *****************************

ver 2.1.39 (2014-02-14)
====================================================================
- 스크린 리더기에서 data-tap 인식할 수 있도록 click 이벤트 bind 추가

ver 2.1.38 (2014-02-11)
====================================================================
- httpSend에서 Content Type Form이 가능 하도록 추가.(setFormContentType 옵션 추가)
- httpSend에서 content-type에 세미콜론 제거.
 
ver 2.1.37 (2014-01-09)
====================================================================
- IE에서 html position fixed와 window.print()를 함께 사용할 시 에러 수정. 

ver 2.1.36 (2014-01-03)
====================================================================
- Android 4+ 삼성 기본브라우저에서 layer popup 호출 시 position fixed 관련 버그 수정.

ver 2.1.35 (2014-01-02)
====================================================================
- sort table default title 설정 값 수정.
- mobile device에서 layer popup close 시 뒤의 버튼 클릭되는 현상 수정.

ver 2.1.34 (2013-12-19)
====================================================================
- IE10에서 호환성 보기로 로드 할 경우 tabindex를 0으로 지정 후 focus()시 에러 발생하는 브라우저 버그 처리

ver 2.1.33 (2013-12-16)
====================================================================
- a 태그 keydown 이벤트 처리 로직 제거

ver 2.1.32 (2013-12-12)
====================================================================
- fixedlength(특정 글자 수만 입력 가능) validate rule 추가.

ver 2.1.31 (2013-12-09)
====================================================================
- IE8에서 textarea scroll 이상 현상 2차 수정.(hoverstyle 적용 로직 제거)

ver 2.1.30 (2013-12-02)
====================================================================
- frag navigate setHeader로직 수정.
- frag navigate와 httpsend의 commonheader 속성 append 가능 구조로 수정.
- Dialog의 top position이 (-)일 때 0으로 세팅하도록 수정.
- view navigate의 option 매개변수에 target 속성 추가.

ver 2.1.29 (2013-11-26)
====================================================================
- validateResponse config에서 frag navigate의 target element를 사용 할 수 있도록 수정.
- IE9에서 Ajax로 대량의 Table Cell 수신 시 Cell이 깨지는 IE9 bug 처리 로직 2차 수정.

ver 2.1.28 (2013-11-19)
====================================================================
- DatePicker 영문 '월' 영역 약자로 수정.(January -> Jan)
- Table Sort 컬럼내의 같은 value끼리의 정렬 로직 2차 수정.(같은 value끼리는 정렬 제외)

ver 2.1.27 (2013-11-14)
====================================================================
- IE9에서 Ajax로 대량의 Table Cell 수신 시 Cell이 깨지는 IE9 bug 처리 로직 추가.

ver 2.1.26 (2013-11-11)
====================================================================
- Table Sort시 오름차순, 내림차순 title 추가.
- Table Sort 컬럼내의 같은 value끼리의 정렬 로직 수정.
- Validator 규칙(alphabethan : 한글, 영문만 가능) 추가.

ver 2.1.25 (2013-10-28)
====================================================================
- Dialog open시 body scroll 여부 체크 로직 수정.
- Table sort의 data-sort-function 적용 로직 수정.

ver 2.1.24 (2013-10-22)
====================================================================
- keyboard로 Dialog open 후 close시 포커스 return하는 로직 수정
- Dialog open 시 body scroll을 disabled 설정하는 로직 추가.
- form validator 성능개선 2차 적용.
- Paging 번호 element에 href 속성 추가 및 현재 element에 title 속성 추가.

ver 2.1.23 (2013-10-15)
====================================================================
- additionalParam append시 중복된 key 체크 로직 추가
- IE에서 <a> 태그에 enter key로 tap 이벤트 수행되지 않는 버그 수정.

ver 2.1.22 (2013-10-01)
====================================================================
- select 태그의 required 규칙 메세지 추가.
- IE8에서 textarea scroll 이상 현상 수정.
- IE7 z-index 버그 분기로직에 기존 userAgent 체크로직 복구.

ver 2.1.21.1 (2013-09-26)
====================================================================
- IE일 경우 Dialog focus 라인 제거(호환성 보기로 할 경우 잔상 생김)
- IE7 documentMode로 z-index 버그 분기로직 수정.

ver 2.1.21 (2013-09-24)
====================================================================
- movable dialog 전체 영역 drag 오류 수정.
- movable dialog offsetTop,offsetLeft가 0보다 작을 때의 처리로직 수정.

ver 2.1.20.2 (2013-09-12)
====================================================================
- data-dialog-movecursor 속성 null 체크 로직 추가.

ver 2.1.20.1 (2013-09-10)
====================================================================
- data-dialog-movecursor 속성을 movable option 설정 최우선으로 수정.

ver 2.1.20 (2013-09-10)
====================================================================
- frag navigate ajax timeout 추가(120 sec)
- frag navigate, httpSend의 timeout option 설정 추가
- data-dialog-movecursor 속성 추가
- dialog open 시 body scroll hidden 로직 제거
- DatePicker mindate, maxdate 이외 날짜 클릭 시 close 안되도록 수정.

ver 2.1.19 (2013-09-03)
====================================================================
- Alopex checkbrowser API 수정(webkit -> chrome, safari로 분리)
- httpSend ajax timeout 수정(120 sec)

ver 2.1.18 (2013-08-20)
====================================================================
- Form Validator 성능 개선(IE7에서 대용량의 element에 적용 시 속도 저하 문제)

ver 2.1.17 (2013-08-13)
====================================================================
- Dialog 동적 생성 시 window.afDialogNumber 값이 초기화 되는 현상 수정.

ver 2.1.16 (2013-08-06)
====================================================================
- IE7에서 Dialog open 시 IE7 z-index bug로 인한 이상 현상 수정.

ver 2.1.15 (2013-07-25)
====================================================================
- frag navigate의 done(), fail() method chain 이상현상 수정.
- Dialog reposition() 사용자 메소드 추가.

ver 2.1.14 (2013-07-22)
====================================================================
- IE7에서 Dialog open 시 body의 overflow:hidden이 되지 않는 현상 수정.
- jquery UI slider와 같은 메소드 명 사용으로 인한 이상현상 수정.

ver 2.1.13 (2013-07-04)
====================================================================
- IE7에서 Dialog의 지정된 style 값이 사라지는 버그 수정.
- validator 숫자, 한글만 허용하는 메소드 추가

ver 2.1.12 (2013-07-02)
====================================================================
- Table Sorting 기능 refactoring 적용.
- navigate, httpSend 에서 개별적으로 useProgress 속성 적용 가능 하도록 수정.

ver 2.1.11 (2013-06-19)
====================================================================
- dialog type 지정 없이도 movable 가능 하도록 수정.

ver 2.1.10 (2013-06-14)
====================================================================
- navigate(.view)의 파라미터에 "(큰따옴표)가 있을 경우 value가 손실되는 버그 수정.

ver 2.1.9 (2013-06-04)
====================================================================
- input type="file" element의 file size 유실되는 버그 수정.
- 사용자 errorcallback이 null일 경우에만 defaultError callback을 호출 하도록 수정.
- defaultHeaders config 명을 commonHeaders로 수정.

ver 2.1.8 (2013-05-30)
====================================================================
- navigate 수행 시 form 안에 input type="file" element가 유실되는 버그 수정.
- navigate, httpSend에 additionalParam config 추가.

ver 2.1.7.1 (2013-05-09)
====================================================================
- IE환경에서 Modal 다이얼로그를 클릭했을때 다이얼로그가 background로 사라지는 버그 수정.(20130509)
- navigate시 form 내의 textarea와 data-placeholder 속성이 적용된 select의  value값이 전달 안되는 버그 수정.

ver 2.1.7 (2013-05-07)
====================================================================
- DatePicker 닫기 버튼 keyboard focus 를 맨 마지막으로 이동 및 control 버튼에 title 속성 추가
- DatePicker hashchange event handler 추가
- 다이얼로그 오픈시 최초 포커스 초점이 다이얼로그 상단으로 가게 수정.
- Modal 다이얼로그에서 키보드 포커싱이 다이얼로그 밖으로 나가지 못하게 수정.

ver 2.1.6 (2013-04-30)
====================================================================
- Navigate : form으로 기존 전체화면 전환 시 form의 element를 hidden form에 붙이도록 작성하였는데
  form에 target을 지정하여 화면전환하는 과정에서 기존 element가 아예 hidden form으로 이동하여 사라지는것을 확인.
  이에 대해 element를 clone하도록 수정 (20130430)
- Navigate : 부분로딩시 method가 POST로 지정된 경우, parameter로 JSON을 보낼 때엔
  JSON string이 request body에, parameter로 form을 보낼 때엔 request parameter에
  form 데이터를 보내도록 수정. (20130425)
- Modal 다이얼로그의 뒷배경화면을 막는 element.blocker의 z-index 속성값 조정(20130430).

ver 2.1.5.1 (2013-04-11)
====================================================================
- Validator에서 textarea 태그를 무시하던 문제 수정.
- DatePicker에서 resize event 발생 시 inline style DatePicker가 popup style로 변하는 버그 수정.
- 다이얼로그 위치 재설정(윈도우 사이즈 조절시)하는 함수내 오류메시지 발생시키는 버그 수정.  (20130411)

ver 2.1.5 (2013-04-09) 
====================================================================
- 셀렉트박스 아이템 선택에 따라 css width값을 auto로 바꾸는 소스 제거.  (20130404)
- DatePicker inLine style 기능 추가 (20130405)

ver 2.1.4 (2013-04-02) 
====================================================================
- position:relative 컨테이너에서 다이얼로그가 화면 가운데로 정렬되지 않는 버그 수정.
- 다이얼로그가 오픈된 상태에서 다시 다이얼로그 열기버튼을 눌렀을때 다이얼로그 타이틀이 사라지는 버그 수정.
- 다이얼로그가 떠있는 갯수를  window.afDialogNumber에 저장하여 참조하도록 수정. 
- IE환경에서 셀렉트박스 아이템 선택시 크기가 0px로 작아지는 버그 수정. 
- Validator에서 form에 대해 submitHandler 옵션 지정에 따른 핸들러 호출이 일어나지 않던 버그 수정.
- list 컴퍼넌트 : refresh 함수 추가.
- DatePicker 특정 날짜 범위만 선택, 이동할 수 있는 Date Range 설정 기능 추가

ver 2.1.3.1 (2013-03-28) 
====================================================================
- paging : data-selected 속성 추가(첫 로딩 시 선택된 페이지 지정)
  농협 프로젝트에서 페이지 선택 시 마다 jsp 재로딩을 하여, 이전에 선택된 페이지 데이터 소멸됨. 
  이에 data-selected 속성을 추가하여, 선택된 페이지를 로딩할 수 있게 변경하고 서비스 전문에 선택된 페이지 정보 추가.
- paging : 선택된 페이지 <a> 태그를 감싸는 <strong> 태그 추가.

ver 2.1.3 (2013-03-26) 
====================================================================
- Alopex Validator의 Validator.setMessage() API를 통한 검증메소드에 따른 에러메세지 지정시
  String 생성 함수를 지정할 수 있음. 이때 함수의 this는 Validator instance이며, 함수의 첫번째 파라메터는
  검증 대상 element임. 또한, 에러메세지로 String을 직접 지정하는 경우 {attr:속성명}을 사용할 경우
  검증 대상 Element의 attribute값을 읽어서 치환할 수 있도록 함. (20130325)
- paging 컴퍼넌트: IE 브라우져에서 발생하는 에러 수정. 기존 HTML 프로퍼티 (ul 태그의 type 속성)와 충돌이 원인. (20130326)
- paging 컴퍼넌트: 새로운 layout 구조 지원(ul-li 타입 지원). (20130326)

ver 2.1.2.1 (2013-03-22) 
====================================================================
- AlopexOverlay(프로그레스)가 기존에 화면표시(fadein)시간과 화면제거(fadeout)시간을 동일한
  옵션값으로 사용하던 것을, duration/durationOff 두개의 옵션으로 분화시켜 적용. (20130320)
- AlopexOverlay(프로그레스)의 default progress 표시기능에 대해 duration/durationOff
  옵션을 반영하여 등장/제거 애니메이션 효과(fadein/fadeout) 적용 (20130320)
- Alopex Controller - 부분로드시 중복 script load를 허용하도록 수정 (20130322)
- Alopex UI Event Model - jQuery 중복로딩시 이전에 바인드한 이벤트 핸들러를 언바인드 하지 못함.
  이를 피하기 위해 중복로딩 이전에 바인드된 이벤트 핸들러가 실행되지 않도록 수정.(20130322)
- alopexready 에러(현상1:alopexready로 등록된 함수가 여러번 호출. 현상2:실행 중 handler.callback 참조 에러.) 수정. (20130322)
- paging 컴퍼넌트: 이전, 다음 버튼 등 조건에 따라 사라지게 처리. (data-button-behavior="diable"로 설정시 disabled 처리) (20130322)
- paging 컴퍼넌트: setMaxPage 함수 추가. (20130322)

ver 2.1.2 (2013-03-19) 
====================================================================
- 다이얼로그 open 함수 파라미터로 json option (ex. {title:"test", movable:true}) 사용할 수 있도록 수정(20130313)
- log.log 함수 삭제. (20120314)
- tabs 컴퍼넌트 접근성 작업 완료. (20120314)
- $.fn.hasEventHandler 함수 추가.
  이벤트 핸들러 등록 여부 리턴. 
  ex) $(window).hasEventHandler('keydown', handler);(20120314)
- 다이얼로그 포커스이동시 웹접근성 측면에서 컴포넌트의 논리적 이동을 저해하는 document.body.appendChild 부분 삭제(20120318)
- 다이얼로그에 키보드로 focusin 되었을때 다이얼로그가 화면 맨앞으로 나오게 z-index값 수정(20120318)
- 셀렉트버튼 data-disabled IE7에서 적용되지 않는 버그 수정(20120318)

 ver 2.1.1 (2013-03-12)
====================================================================
- contentslider의 next(),prev() method 명 수정.(20130307)
- 다이얼로그 타이틀이 없을 때 자동으로 Dialog 문구를 넣어주는 로직 제거 (20130311)
- 다이얼로그 접근성 향상을 위해서 다이얼로그를 띄웠을때 버튼으로 포커싱하도록 로직추가. (20130311)
- 다이얼로그를 닫은 후, 다이얼로그를 Open한 버튼으로 포커싱이동하는 로직추가. (20130311)
- alopexready()에 두 번째 parameter(condition)추가(20130312)

 ver 2.1.0 (2013-02-28)
====================================================================
- Alopex UI 2.1 BaseLine

*/


/**
 * Copyright (c) 2012 SK C&C Co., Ltd. All rights reserved.
 *
 * This software is the confidential and proprietary information of SK C&C.
 * You shall not disclose such confidential information and shall use it
 * only in accordance with the terms of the license agreement you entered into
 * with SK C&C.
 */

// table내 sorting에 사용.
/* 
Array.prototype.alopexsort = function(func, isAscending) {
  if(func == undefined) {
    func = function(a,b){
      if(a>b)
        return 1;
      if(a<b)
        return -1;
      return 0;

    };
  }
  if(this.length <= 1) {
    return;
  }
  var i, j, newValue;
  for(i=1;i<this.length;i++)
  {
    newValue = this[i];
    j=i;
    if(isAscending) {
      while(j>0 && func(this[j-1], newValue)>0) {
        this[j] = this[j-1];
        j--;
      }
    } else {
      while(j>0 && func(this[j-1], newValue)<0) {
        this[j] = this[j-1];
        j--;
      }
    }
    
    this[j] = newValue;
  }
};*/
try{ 
	Object.defineProperty(Array.prototype, "alopexsort", {
	  enumerable: false,
	  value: function (func, isAscending) {
	    if (func == undefined) {
	      func = function (a, b) {
	        if (a > b)
	          return 1;
	        if (a < b)
	          return -1;
	        return 0;

	      };
	    }
	    
	    if (this.length <= 1) {
	      return;
	    }
	    var i, j, newValue;
	    for (i = 1; i < this.length; i++) {
	      newValue = this[i];
	      j = i;
	      if (isAscending) {
	        while (j > 0 && func(this[j - 1], newValue) > 0) {
	          this[j] = this[j - 1];
	          j--;
	        }
	      } else {
	        while (j > 0 && func(this[j - 1], newValue) < 0) {
	          this[j] = this[j - 1];
	          j--;
	        }
	      }

	      this[j] = newValue;
	    }
	  }
	});
	
}catch(e){}

(function($) {
  $.alopex = {

    widget: ['checkbox', 'textinput', 'textarea', 'dialog', 'button', 'select',
        'radio', 'scrollview', 'panel', 'tabs', 'list', 'table',
        'paging', 'progressbar', 'navigationbar',
        'contentslider', 'navmenu', 'tree'],
    chainapi: ['setImage', 'setEnabled', 'setSelected',
        'setSort', 'open', 'close', 'refresh',
        'setTabIndex', 'setSelectedPage', 'setProgress',
        'clear', 'showNaviBar', 'dismissNaviBar', 'nextSlide', 'prevSlide',
        'setTotalPage', 'setMaxPage', 'refresh', 'setDataSource', 'ok', 'cancel', 'confirm', 'setColumnToggleButton',
         'showColumn', 'hideColumn', 'setChecked', 'setCheckAll', 'createNode', 'expand', 'collapse',
         'expandAll', 'collapseAll', 'deleteNode', 'editNode', 'setSelected', 'toggleCheckbox', 'toggleExpand', 'scrollToElement', 'reposition'],
    getterapi: ['getPageIndex', 'getValue', 'getSelectedPage', 'getValues', 'getValue', 'getTexts', 'getText', 
                'getSelectedNode','getCheckedNodes', 'getNode'],

    /**
     * Register plugins for widgets, apis.
     */
    addPlugins: function() {
      /**
       * jQuery Plugin for each component
       */
      $.each($.alopex.widget.concat($.alopex.chainapi), function(i, v) {
        var name = v;
        $.fn[v] = function() {
          var args = arguments;
          return this.each(function() {
            if ($.alopexUtil.isValid(this.getAttribute('data-type'))) {
              if ($.alopexWidget[this.getAttribute('data-type')][v]) {
                $.alopexWidget[this.getAttribute('data-type')][v].apply(this,
                    args);
              }
            }
          });
        };
      });

      /**
       * jQuery Plugin for each component's getter API
       */
      $.each($.alopex.getterapi, function(i, v) {
        var name = v;
        $.fn[v] = function() {
          var args = arguments;
          var el = this[0];
          if ($.alopexUtil.isValid(el.getAttribute('data-type'))) {
            if ($.alopexUtil.isValid($.alopexWidget[el
                .getAttribute('data-type')][v])) {
              return $.alopexWidget[el.getAttribute('data-type')][v].apply(
                  el, args);
            }
          }
        };
      });
    },

    entryFunctions: [],

    // 후실행될 작업 리스트.
    delayed: [],

    domready: false,

    init: function() {
      if (window.console == undefined) { console = { log: function() {} }; }

      $.alopex.domready = true;
      $.alopex.addPlugins();
      $.alopex.checkBrowser();
      $.alopex.start();
    },

    start: function() {

      function timer() {
        var removed = [];
        for(var i=0; i<$.alopex.entryFunctions.length; i++) {
          try{
            var condition = $.alopex.entryFunctions[i].condition();
            if(condition) {
              removed.push(i);
            }
          }catch(e) {}
        }

        for(var i=0; i<removed.length; i++) {
          var handler = $.alopex.entryFunctions[removed[i]-i];
          $.alopex.entryFunctions.splice(removed[i]-i, 1);
          handler.callback.apply();
        }

        if($.alopex.entryFunctions.length !=  0) {
          setTimeout(timer, 500);
        }
      }

      $.alopex.convert(document.body);
      // 동기화 맞추어 주기 위해
      for (var i=0; i<$.alopex.delayed.length;) {
        var delayed = $.alopex.delayed.shift();
        delayed.apply();
      }

      setTimeout(timer, 500);

      $(document).trigger('alopexready');
    },

    checkBrowser: function() {
      // Browser Check
      if ((/iphone|ipad/gi).test(navigator.appVersion) ||
          (/android/gi).test(navigator.appVersion)) {
        window.browser = 'mobile';
      } else if (navigator.userAgent.toLowerCase().indexOf('msie') !== -1) {
        window.browser = 'ie';
      } else if (navigator.userAgent.toLowerCase().indexOf('chrome') !== -1) {
        window.browser = 'chrome';
      } else if (navigator.userAgent.toLowerCase().indexOf('safari') !== -1) {
        window.browser = 'safari';
      } else if (navigator.userAgent.toLowerCase().indexOf('gecko') !== -1) {
        window.browser = 'firefox';
      } else if (navigator.userAgent.toLowerCase().indexOf('opera') !== -1) {
        window.browser = 'opera';
      }
    },

    convert: function(container) {
      $(container).find('[data-type]').each(function() {
        var type = $(this).attr('data-type');
        if ($.alopexUtil.isValid($.fn[type]) && !this.converted) {
          $(this)[type].apply($(this));
        }
      });
    },
    
    responsive: {
      threshold: 600
    }
  };

  $.alopexUtil = {
    isValid: function(variables) {
      if (variables == null || variables == undefined || variables === '' ||
          variables == 'undefine') {
        return false;
      } else {
        return true;
      }
    },

    parseBoolean: function(string) {
      switch (String(string).toLowerCase()) {
        case "true":
        case "1":
        case "yes":
        case "y":
          return true;
        case "false":
        case "0":
        case "no":
        case "n":
          return false;
        default:
          return undefined;
      }
    },
    
    hasClass: function(ele, cls) {
      return ele.className.match(new RegExp('(\\s|^)' + cls + '(\\s|$)'));
    },

    addClass: function(ele, cls) {
      if (!$.alopexUtil.hasClass(ele, cls)) {
        ele.className += ' ' + cls;
      }
    },

    removeClass: function(ele, cls) {
      if ($.alopexUtilhasClass(ele, cls)) {
        var reg = new RegExp('(\\s|^)' + cls + '(\\s|$)');
        ele.className = ele.className.replace(reg, ' ');
      }
    },

    regexp: {
      number: /^[0-9]+$/,

      date: /(^\d{1,2}(\-|\/|\.)\d{1,2}(\-|\/|\.)\d{4}$)|(^\d{4}(\-|\/|\.)\d{1,2}(\-|\/|\.)\d{1,2}$)/,

      divider: /^\-|\/|\./
    },

    getWindowHeight: function() {
      return $(window).height();
    },

    getWindowWidth: function() {
      return $(window).width();
    },

    getDocumentHeight: function() {
      return $(document).height();
    },

    getDocumentWidth: function() {
      return $(document).width();
    },
    
    getPagePosition: function(el) {
      var leftPosition = topPosition = 0;
      if (el.offsetParent) {
        topPosition = el.offsetTop;
        leftPosition = el.offsetLeft;
        while (el = el.offsetParent) {
          topPosition += el.offsetTop;
          leftPosition += el.offsetLeft;
        }
      }
      return [topPosition, leftPosition];
    },
    
    getScrolledPosition: function(el) {
      var leftPosition = topPosition = 0;
      if (el.offsetParent) {
        topPosition = el.offsetTop - el.scrollTop;
        leftPosition = el.offsetLeft - el.scrollLeft;
        while (el = el.offsetParent) {
          topPosition += el.offsetTop - el.scrollTop;
          leftPosition += el.offsetLeft - el.scrollLeft;
        }
      }
      return [topPosition, leftPosition];
    },
    
    getScrollbarWidth: function() {
      var parent, child, width;
      if(width===undefined) {
        parent = $('<div style="width:50px;height:50px;overflow:auto"><div/></div>').appendTo('body');
        child=parent.children();
        width=child.innerWidth()-child.height(99).innerWidth();
        parent.remove();
      }
     return width;
    },

    isNumberType: function(data) {
      return $.alopexUtil.regexp.number.test(data);
    },

    isDateType: function(data) {
      return $.alopexUtil.regexp.date.test(data);
    },

    /**
     * array에 존재하는 데이터를 분석하여, 해당 데이터에 맞는 sorting 함수 리턴.
     * @param {Array} array input data array.
     * @return {string} data type.
     */
    guessType: function(array) {
      var sortingType = null; // 초기 설정값.
      var type;
      for (var i = 0; i < array.length; i++) {
        type = ''; // 데이터 하나 판단할 떄 초기 설정 값.
        if ($.alopexUtil.isNumberType(array[i])) { // number check
          type = 'number';
        } else if ($.alopexUtil.isDateType(array[i])) { // date check
          type = 'date';
        } else {
          type = 'string';
        }
        if (sortingType == null) {
          sortingType = type; //
        } else if (sortingType != type) {
          return 'string';
        }
      }

      return sortingType;
    },

    /**
     *
     * @param {array} array 스트링 배열. 안에 date string 들이 들어 있음.
     * @return {array} array 스트링 배열. DDMMYYYY로 변환한다.
     */
    formatDate: function(array) {
      var type = 'ddmm';

      // ddmm or mmdd 판단.
      for (var i = 0; i < array.length; i++) {
        var divider = array[i].match($.alopexUtil.regexp.divider);
        var data = array[i].split(divider);

        if (data[0].length == 4) { // 이 부분에서 YYYY 뒤로 이동.
          data.push(data[0]);
          data.shift();
          array[i] = data.join('/');
        }

        if (parseInt(data[0]) > 12) {
          type = 'mmdd';
          break;
        }
      }

      if (type == 'mmdd') {
        for (var i = 0; i < array.lengh; i++) {
          var divider = array[i].match($.alopexUtil.regexp.divider);
          var data = array[i].split(divider);

          var temp = data[0];
          data[0] = data[1];
          data[1] = temp;
          array[i] = data.join('/');
        }
      }

      return array;
    },

    /**
     * 새로운 HTML 노드를 생성하고, 기존 엘리먼트에서 있는 속성(attribute) 복사.
     * @param {string} tagName 새로운 HTML 노드의 태그이름 명시.
     */
    copyNode: function(oldNode, tagName) {
      if (tagName == undefined) {
        tagName = oldNode.tagName;
      }
      var newNode = document.createElement(tagName);
      for (var i = 0; i < oldNode.attributes.length; i++) {
        var attr = oldNode.attributes[i];
        $(newNode).attr(attr.name, attr.value);
      }
      return newNode;
    },

    sort_numeric: function(a, b) {
      var num1 = parseFloat(a[0].replace(/[^0-9.-]/g, ''));
      if (isNaN(num1))
        num1 = 0;
      var num2 = parseFloat(b[0].replace(/[^0-9.-]/g, ''));
      if (isNaN(num2))
        num2 = 0;
      return num1 - num2;
    },
    sort_alpha: function(a, b) {
      if (a[0] == b[0])
        return 0;
      if (a[0] < b[0])
        return -1;
      return 1;
    },

    sort_date: function(a, b) { // DD/MM/YYYY
      var date1 = $.alopexUtil.getDate(a[0]);
      var date2 = $.alopexUtil.getDate(b[0]);

      if (date1 > date2)
        return 1;
      else if (date1 == date2)
        return 0;
      else
        return -1;
    },

    /**
     *
     * @param {string} date string type.
     * @return {Date Object} Javascript Date Object.
     */
    getDate: function(date, option) {
      var year, month, day;
      if (option == undefined) {
        option = 'ddmm';
      }

      var divider = '/';
      divider = date.match(/\-|\/|\./);
      var dateArr = date.split(divider);
      year = dateArr[2];
      if (option == 'ddmm') {
        month = dateArr[1];
        day = dateArr[0];
      } else {
        month = dateArr[0];
        day = dateArr[1];
      }
      return new Date(year, month, day);
    },
    
    trim: function(str) {
      return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    }
  };

  $.alopexWidget = {

    object: {
      addDefaultStyleClass: function(el, styleClass) {
        //Theme Determination (default : af-default)
        var defaultTheme = ' af-default';
        if (el.getAttribute('data-theme') != undefined) {
          defaultTheme = ' ' + el.getAttribute('data-theme');
        }
        if (el.className != undefined && el.className != '') {
          // class name define
          if (defaultTheme != ' af-default') {
            el.defaultStyleClass = el.className + defaultTheme;
          } else {
            el.defaultStyleClass = el.className;
          }
        } else { // no class
          el.defaultStyleClass = styleClass + defaultTheme;
        }
        if (el.getAttribute('data-style') != undefined) { // CustomStyle apply.
          el.defaultStyleClass += ' ' + el.getAttribute('data-style');
        }

        $(el).attr('class', el.defaultStyleClass)
          .attr('data-converted', 'true');
        el.pressStyleClass = 'af-pressed'; // 이름 정해야 함.
        el.converted = true;
      },

      addHighlight: function(el) {
        $(el).bind('pressed', $.alopexWidget.object._addPressedStyle);
        $(el).bind('move', $.alopexWidget.object._removePressedStyle);
        $(el).bind('unpressed', $.alopexWidget.object._removePressedStyle);
        $(el).bind('hoverstart', $.alopexWidget.object._addHoverStyle);
        $(el).bind('hoverend', $.alopexWidget.object._removeHoverStyle);
      },

      _addPressedStyle: function(e) {
        if(e.alopexStopStyling) {
          return;
        }
        var el = e.currentTarget;
        switch (el.getAttribute('data-type')) {
        case 'select' | 'textinput' | 'textarea':
          break;
        default:
          el.defaultStyleClass = el.className;
          if (el.pressStyleClass == undefined || el.pressStyleClass == null ||
              el.pressStyleClass == '')
            el.pressStyleClass = 'af-pressed';
          $(el).addClass(el.pressStyleClass);
          break;
        }
        e.alopexStopStyling = true;
      },

      _removePressedStyle: function(e) {
        if(e.alopexStopStyling) {
          return;
        }
        var el = e.currentTarget;
        switch (el.getAttribute('data-type')) {
        case 'select' | 'textinput' | 'textarea':
          break;
        default:
          if (el.pressStyleClass == undefined || el.pressStyleClass == null ||
              el.pressStyleClass == '')
            el.pressStyleClass = 'af-pressed';
          $(el).removeClass(el.pressStyleClass);
        }
        e.alopexStopStyling = true;
      },

      _addHoverStyle: function(e) {
        if(e.alopexStopStyling) {
          return;
        }
        var el = e.currentTarget;
        switch (el.getAttribute('data-type')) {
        case 'select' | 'textinput' | 'textarea':
          break;
        default:
          el.defaultStyleClass = el.className;
          if (el.hoverStyleClass == undefined || el.hoverStyleClass == null ||
              el.hoverStyleClass == '')
            el.hoverStyleClass = 'af-hover';
          $(el).addClass(el.hoverStyleClass);
          break;
        }
        e.alopexStopStyling = true;
      },

      _removeHoverStyle: function(e) {
        if(e.alopexStopStyling) {
          return;
        }
        var el = e.currentTarget;
        switch (el.getAttribute('data-type')) {
        case 'select' | 'input':
          break;
        default:
          if (el.hoverStyleClass == undefined || el.hoverStyleClass == null ||
              el.hoverStyleClass == '')
            el.hoverStyleClass = 'af-hover';
          $(el).removeClass(el.hoverStyleClass);
        }
        e.alopexStopStyling = true;
      },
      
      _addDisabledStyle: function(el){
        if (el.disabledStyleClass == undefined || el.disabledStyleClass == null ||
            el.disabledStyleClass == '')
          el.disabledStyleClass = 'af-disabled';
        $(el).addClass(el.disabledStyleClass);
      },

      _removeDisabledStyle: function(el){
        if (el.disabledStyleClass == undefined || el.disabledStyleClass == null ||
            el.disabledStyleClass == '')
          el.disabledStyleClass = 'af-disabled';
        $(el).removeClass(el.disabledStyleClass);
      },

      fillVertical: function(el) {
        var parentHeight = el.parentNode.offsetHeight;
        var siblingHeight = 0;
        var children = el.parentNode.children;

        for (var i = 0; i < children.length; i++) {
          if (children[i] != el) {
            // check floated element
            if (children[i].style.position != 'absolute') {
              siblingHeight += children[i].offsetHeight;
              if (!isNaN(parseInt($(children[i]).css('margin-top'))))
                siblingHeight += parseInt($(children[i]).css('margin-top'));
              if (!isNaN(parseInt($(children[i]).css('margin-bottom'))))
                siblingHeight += parseInt($(children[i]).css('margin-bottom'));
            }
          }
        }
        $(el).css('height', (parentHeight - siblingHeight) + 'px');
      },

      fillHorizontal: function(el) {
        var parentWidth = el.parentNode.offsetWidth;
        var siblingWidth = 0;
        var children = el.parentNode.children;
        for (var i = 0; i < children.length; i++) {
          if (children[i] != el) {
            if (children[i].style.position != 'absolute') {
              siblingWidth += children[i].offsetWidth;
              if (!isNaN(parseInt($(children[i]).css('margin-left'))))
                siblingWidth += parseInt($(children[i]).css('margin-left'));
              if (!isNaN(parseInt($(children[i]).css('margin-right'))))
                siblingWidth += parseInt($(children[i]).css('margin-right'));
            }
          }
        }
        el.style.width = (parentWidth - siblingWidth) + 'px';
      }
    },

    button: {
      button: function(options) {
        var el = this;
        $.alopexWidget.object.addDefaultStyleClass(el, 'af-button');
        $.alopexWidget.object.addHighlight(el);
        $(this).bind('selectstart', function(e) {
          e.preventDefault();
          return false;
        });
        $(this).bind('dragstart', function(e) {
          e.preventDefault();
          return false;
        });
        
        if ($.alopexUtil.isValid($(el).attr('data-disabled')) && $.alopexUtil.parseBoolean($(el).attr('data-disabled'))) {
          el.enabled = false;
        } else {
          el.enabled = true;
          el.original = el;
        }
        
        if (!el.enabled) {
          $(el).setEnabled(el.enabled);
        }
      },

      setEnabled: function(bool) {
        var el = this;
        el.enabled = bool;
        if (el.enabled) {
          this.parentNode.replaceChild(this.original, this);
        } else {
          if (this.clone == undefined) {
            var clone = this.cloneNode(true);
            $(clone).attr('disabled', 'disabled');
            $.alopexWidget.object._addDisabledStyle(clone);
            clone.original = this;
            this.clone = clone;
          }
          this.parentNode.replaceChild(this.clone, this);
        }
      }
    },

    checkbox: {
      checkbox: function(options) {
        var el = this;
        $.alopexWidget.object.addDefaultStyleClass(el, 'af-checkbox');
        
        var date = new Date();
        if ($(el).attr('id') == null) {
          $(el).attr('id', 'a' + (date.getTime() + Math.floor(Math.random() * 1000000) + 1));
        }
        
        if ($.alopexUtil.isValid($(el).attr('data-disabled')) && $.alopexUtil.parseBoolean($(el).attr('data-disabled'))) {
          el.enabled = false;
        } else {
          el.enabled = true;
        }
        
        if (!el.enabled) {
          $(el).setEnabled(el.enabled);
        }
      },

      setChecked: function(bool) {
        var el = this;

        if (el.tagName == 'INPUT') {
          if (bool != null) {
            if (bool) {
              el.checked = true;
            } else {
              el.checked = false;
            }
          } else {
            if (el.checked) {
              el.checked = false;
            } else {
              el.checked = true;
            }
          }
        }
      },
      
      setCheckAll: function(bool) {
        var el = this;

        if (bool == null) {
          bool = true;
        }

        var checkList = $('input[name=' + el.name + ']');
        for (var i = 0; i < checkList.length; i++) {
          var obj = checkList[i];
          if (bool) {
            obj.checked = true;
          } else {
            obj.checked = false;
          }
        }
      },
      
      getValues : function() {
        var el = this;
        var tmpValuesArr = [];

        var checkList = $("input[name=" + el.name + "]:checked");
        for (var i=0; i < checkList.length;i++) {
            var obj = checkList[i];
            tmpValuesArr.push($(obj).val());
        }
        return tmpValuesArr;
      },
      
      getTexts: function() {
        var el = this;
        var tmpTextsArr = [];
        
        var checkList = $("input[name=" + el.name + "]:checked");
        for (var i=0; i < checkList.length;i++) {
          var obj = checkList[i];
          var elId = $(obj).attr('id');
          var el_label = $(el).parent().find("label[for=\'" + elId + "\']");
          
          tmpTextsArr.push($(el_label).text());
        }
        return tmpTextsArr;
      },
      
      setEnabled: function(boolean) {
        var el = this;
        el.enabled = boolean;
        var elId = $(el).attr('id');
        var el_label = $(el).parent().find("label[for=\'" + elId + "\']");

        if (el.enabled) {
          $(el).removeAttr('disabled');
          $.alopexWidget.object._removeDisabledStyle(el);
          $.alopexWidget.object._removeDisabledStyle(el_label);
        } else {
          $(el).attr('disabled', 'disabled');
          $.alopexWidget.object._addDisabledStyle(el);
          $.alopexWidget.object._addDisabledStyle(el_label);
        }
      }
    },

    dialog: {
      maxZindex: 1000,
      
      dialog: function(options) {
        var dialog = $.alopexWidget.dialog;
        var el = this;
        // set animation value
        el.animation = $(el).attr('data-animation');
        if ($.alopexUtil.isValid($(el).attr('data-animationtime'))) {
          if (typeof($(el).attr('data-animationtime'))=="string") {
            el.anitime = Number($(el).attr('data-animationtime'));
          } else {
            el.anitime = $(el).attr('data-animationtime');
          }
        } else {
          el.anitime = 500;
        }
        // set resizable
        if ($.alopexUtil.isValid($(el).attr('data-resizable')) && $.alopexUtil.parseBoolean($(el).attr('data-resizable'))) {
          el.resizable = true;
        } else {
          el.resizable = false;
        }
        // set movable
        if ($.alopexUtil.isValid($(el).attr('data-dialog-movable')) && $.alopexUtil.parseBoolean($(el).attr('data-dialog-movable'))) {
          el.movable = true;
        } else {
          el.movable = false;
        }
        // set modal
        if ($.alopexUtil.isValid($(el).attr('data-dialog-modal')) && $.alopexUtil.parseBoolean($(el).attr('data-dialog-modal'))) {
          el.modal = true;
        } else {
          el.modal = false;
        }
        //set dialogType
        if ($.alopexUtil.isValid($(el).attr('data-dialog-type'))) {
            el.dialogType = $(el).attr('data-dialog-type').toLowerCase();
        } else {
          el.dialogType = false;
        }
        
        var date = new Date();
        if ($(el).attr('id') == null) {
          $(el).attr('id', 'a' + (date.getTime() + Math.floor(Math.random() * 1000000) + 1));
        }
        
        $(el).attr('style',
            ($(el).attr('style') ? $(el).attr('style') : '') +
            ';position:fixed;z-index:1000;opacity:0;overflow:hidden;');
        /*$.alopex.delayed.push(function() {
            $(el).css('display', 'none'); 
        });*/

        //contents
        if ($.alopexUtil.isValid($(el).children()[0])) {
          el.contents = $(el).children()[0];
        }

        dialog._setDialogType(el, el.dialogType);
        dialog._setResizable(el, el.resizable);
        dialog._setMovable(el, el.movable);
        dialog._setModal(el, el.modal);
        
        $(el).bind('pressed', dialog._moveToTop);
        $(el).focusin(dialog._moveToTop);
        $(el).bind('keydown', dialog._addKeydownEvent);
        
        if(window.afDialogNumber == undefined){
          window.afDialogNumber = 0;
        }
        
        //origin size setting
        el.originWidth = $(el).width();
        el.originHeight = $(el).height();
        
        $(el).css("display", "none");
      },
      
      _addKeydownEvent: function(e) {
        var el = $('#'+this.id)[0];
        var code = e.keyCode != null ? e.keyCode : e.which;
        
        switch(code) {
        case 27:
          $(el).close();
          break;
        case 9:
          if (el.modal) {
            var selectorcondition = 'a[href], area[href], input:not([disabled]), select:not([disabled]), ' + 
              'textarea:not([disabled]), button:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable]';
            if (e.shiftKey) {
              if (document.activeElement == $(this)[0] || document.activeElement == $(this).find(selectorcondition).first()[0]) {
                $($(el).find(selectorcondition).last()).focus();
                e.preventDefault();
              }
              break;
            }
            if (document.activeElement == $(this).find(selectorcondition).last()[0]) {
              $($(el).find(selectorcondition).first()).focus();
              e.preventDefault();
            }
          }
          break;
        default:
          break;
        }
      },
      
      _setDialogType: function(el, type) {
        if (type == "blank" || type == "close" || type == "confirm" || type == "okcancel") {
          // header
          el.header = document.createElement('div');
          $(el.header).attr('id', $(el).attr('id') + '-header');
          $(el.header).attr('class', 'dialog_header');

          var closebtn = document.createElement('button');
          $(closebtn).attr('id', $(el).attr('id') + '_closebtn');
          $(closebtn).attr('class', 'dialog_btn');
          $(closebtn).tap(function(){
            $('#' + $(el).attr('id')).close();
          });
          $.alopexWidget.object.addHighlight(closebtn);
          el.header.appendChild(closebtn);

          $(el).prepend(el.header);

          //contents
          if ($.alopexUtil.isValid(el.contents)) {
            el.appendChild(el.contents);
          }
          
          if (type == "close") {
            //button
            el.button = document.createElement('div');
            $(el.button).attr('class', 'dialog_btn');
            $.alopexWidget.object.addHighlight(el.button);
            if (!el.resizable) {
              $(el.button).attr('style', 'padding-bottom:0px !important;');
            }
            
            var closebtn = document.createElement('button');
            $(closebtn).attr('id', $(el).attr('id') + '_close');
            $(closebtn).attr('data-type', 'button');
            $(closebtn).attr('style', 'float:right;');
            $(closebtn).text('Close');
            
            $(closebtn).button();
            
            el.button.appendChild(closebtn);
            el.appendChild(el.button);
          } else if (type == "confirm") {
          //button
            el.button = document.createElement('div');
            $(el.button).attr('class', 'dialog_btn');
            $.alopexWidget.object.addHighlight(el.button);
            if (!el.resizable) {
              $(el.button).attr('style', 'padding-bottom:0px !important;');
            }
            
            var confirmbtn = document.createElement('button');
            $(confirmbtn).attr('id', $(el).attr('id') + '_confirm');
            $(confirmbtn).attr('data-type', 'button');
            $(confirmbtn).attr('style', 'float:right;');
            $(confirmbtn).text('Confirm');
            
            $(confirmbtn).button();
            
            el.button.appendChild(confirmbtn);
            el.appendChild(el.button);
          } else if (type == "okcancel") {
            //button
            el.button = document.createElement('div');
            $(el.button).attr('class', 'dialog_btn');
            $.alopexWidget.object.addHighlight(el.button);
            if (!el.resizable) {
              $(el.button).attr('style', 'padding-bottom:0px !important;');
            }
            
            var okbtn = document.createElement('button');
            $(okbtn).attr('id', $(el).attr('id') + '_ok');
            $(okbtn).attr('data-type', 'button');
            $(okbtn).attr('style', 'position: absolute;right: 80px;');
            $(okbtn).text('Ok');

            var cancelbtn = document.createElement('button');
            $(cancelbtn).attr('id', $(el).attr('id') + '_cancel');
            $(cancelbtn).attr('data-type', 'button');
            $(cancelbtn).attr('style', 'float:right;');
            $(cancelbtn).text('Cancel');
            
            $(okbtn).button();
            $(cancelbtn).button();
            
            el.button.appendChild(okbtn);
            el.button.appendChild(cancelbtn);
            el.appendChild(el.button);
          }
        }
      },
      
      _setModal: function(el, modal) {
        var object = $.alopexWidget.object;
        object.addDefaultStyleClass(el, 'af-dialog');
        if (modal != null && modal) {
          el.modal = true;
          
          el.blocker = document.createElement('div');
          $(el.blocker).attr('style', 'overflow:hidden;display:none;' +
          'z-index:999;position:absolute;left:0;top:0;');
          $(el.blocker).css('opacity', 0.5);
          $(el.blocker).css('-ms-filter', 'progid:DXImageTransform.Microsoft.Alpha(Opacity=50)');
          document.body.appendChild(el.blocker);
          
          object.addDefaultStyleClass(el.blocker, 'af-dialog-mask');
        } else {
          el.modal = false;
        }
      },
      
      _setMovable: function(el, movable) {
        var dialog = $.alopexWidget.dialog;
        if (movable != null && window.browser != 'mobile' && movable) {
          el.movable = true;
          
          var data = {};
          data.container = el;
          
          var childrenLength = $(el).children().length;
          if (childrenLength > 0) {
            if ($.alopexUtil.isValid(el.header)){
              $(el.header).bind('pressed', data, dialog._preMoveDialog);
              $(el.header).css('cursor', 'move');
            } else{
              $($(el).find('[data-dialog-movecursor=true]')[0]).bind('pressed', data, dialog._preMoveDialog);
              $($(el).find('[data-dialog-movecursor=true]')[0]).css('cursor', 'move');
            }
          }
        } else {
          el.movable = false;
        }
      },
      
      _setResizable: function(el, resizable) {
        var dialog = $.alopexWidget.dialog;
        if (resizable!= null && window.browser != 'mobile' && resizable) {
          el.resizable = true;
          //footer
          el.footer = document.createElement('div');
          $(el.footer).attr('id', $(el).attr('id') + '-footer');
          
          el.left = document.createElement('div');
          $(el.left).attr('id', $(el).attr('id') + '-left');
          $(el.left).attr('style', 'position:absolute;top:0px;left:0px;width:2px;' +
          'height:100%;cursor:w-resize;');
          
          el.right = document.createElement('div');
          $(el.right).attr('id', $(el).attr('id') + '-right');
          $(el.right).attr('style', 'position:absolute;top:0px;right:0px;width:2px;' +
          'height:100%;cursor:col-resize;');
          
          el.bottom = document.createElement('div');
          $(el.bottom).attr('id', $(el).attr('id') + '-bottom');
          $(el.bottom).attr('style', 'position:absolute;left:0px;bottom:0px;' +
          'width:100%;height:2px;cursor:s-resize;');
          
          el.both = document.createElement('div');
          $(el.both).attr('id', $(el).attr('id') + '-both');
          $(el.both).attr('class', 'resizeBtn');
          
          el.footer.appendChild(el.left);
          el.footer.appendChild(el.right);
          el.footer.appendChild(el.bottom);
          el.footer.appendChild(el.both);
          el.appendChild(el.footer);
          
          $(el.left).bind('pressed', dialog._preResizeDialog);
          $(el.right).bind('pressed', dialog._preResizeDialog);
          $(el.bottom).bind('pressed', dialog._preResizeDialog);
          $(el.both).bind('pressed', dialog._preResizeDialog);
        } else {
          el.resizable = false;
        }
      },
      
      _preMoveDialog : function(e, ae) {
        document.onselectstart = function () { return false; };
        
        var dialog =$.alopexWidget.dialog;
        var offset = $(this).offset();
        var data = {};
        data.x = ae.pageX - offset.left;
        data.y = ae.pageY - offset.top;
        data.element = e.currentTarget;
        data.container = e.data.container;
        $(document).bind('move.alopexDialogMove', data, dialog._moveDialog)
                   .bind('unpressed.alopexDialogMove', data, dialog._postMoveDialog);
      },
      
      _moveDialog: function(e, ae) {
        var x = ae.pageX - $(window).scrollLeft();
        var y = ae.pageY - $(window).scrollTop();
        if(!e.data.element) {
          return;
        }

        var parent = e.data.container;
        
        $(parent).css('left', x - e.data.x + 'px');
        if (parent.offsetLeft >= ($(window).width() - $(parent).width())) {
          $(parent).css('left',
              ($(window).width() - $(parent).width()) + 'px');
        }
        if ((parent.offsetLeft) <= 0) {
          $(parent).css('left', '0px');
        }
        
        $(parent).css('top', y - e.data.y + 'px');
        if ($(window).height() <= (parent.offsetTop + $(parent).height())) {
          $(parent).css('top',
              ($(window).height() - $(parent).height()) + 'px');
        }
        if (parent.offsetTop <= 0) {
          $(parent).css('top', '0px');
        }
      },
      _postMoveDialog : function(e, ae) {
        $(document).unbind('.alopexDialogMove');
        document.onselectstart = function () { return true; };
      },

      _preResizeDialog: function(e) {
        var target = e.currentTarget;
        var el = $('#' + target.id.substring(0, target.id.indexOf("-")));
        
        var dialog = $.alopexWidget.dialog;
        $(el[0].left).bind('swipemove', dialog._resizeLeftDialog).bind('unpressed', dialog._postResizeDialog);
        $(el[0].right).bind('swipemove', dialog._resizeRightDialog).bind('unpressed', dialog._postResizeDialog);
        $(el[0].bottom).bind('swipemove', dialog._resizeBottomDialog).bind('unpressed', dialog._postResizeDialog);
        $(el[0].both).bind('swipemove', dialog._resizeBothDialog).bind('unpressed', dialog._postResizeDialog);
        
        document.onselectstart = function () { return false; };
      },
      
      _postResizeDialog: function(e) {
        var target = e.currentTarget;
        var el = $('#' + target.id.substring(0, target.id.indexOf("-")));
        
        $(el[0].left).unbind('swipemove');
        $(el[0].right).unbind('swipemove');
        $(el[0].bottom).unbind('swipemove');
        $(el[0].both).unbind('swipemove');
        
        document.onselectstart = function () { return true; };
      },
      
      _resizeLeftDialog: function(e, ae) {
        var x = ae.pageX - $(window).scrollLeft();
        var el = e.currentTarget;
        var parent = el.parentElement.parentElement;

        var offsetRight =
          $(window).width() - (parent.offsetLeft + $(parent).width());
        var gap = parent.offsetLeft - x;
        var resizedX = $(parent).width() + gap;

        if (resizedX <= parent.originWidth) {
          resizedX = parent.originWidth;
          $(parent).css('width', resizedX + 'px');
          $(parent).children().each(function() {
            if (this.nodeName != "BUTTON") {
              $(this).css('width', resizedX + 'px');
            }
          });
          if ((offsetRight - ae.startX) <= parent.originWidth) {
            $(parent).css('left', ae.startX + 'px');
          }
        } else {
          if ((parent.offsetLeft) <= 0) {
            $(parent).css('left', '3px');
          } else {
            $(parent).css('left', x + 'px');
            $(parent).css('width', resizedX + 'px');
            $(parent).children().each(function() {
              if (this.nodeName != "BUTTON") {
                $(this).css('width', resizedX + 'px');
              }
            });
          }
        }
      },

      _resizeRightDialog: function(e, ae) {
        document.onselectstart = function () { return false; };
        
        var x = ae.pageX - $(window).scrollLeft();
        var el = e.currentTarget;
        var parent = el.parentElement.parentElement;

        var resizedX = x - parent.offsetLeft;

        if (resizedX < parent.originWidth) {
          resizedX = parent.originWidth;
        }

        $(parent).css('width', resizedX + 'px');
        $(parent).children().each(function() {
          if (this.nodeName != "BUTTON") {
            $(this).css('width', resizedX + 'px');
          }
        });
        if ($(parent).width() >=
          ($(window).width() - parent.offsetLeft)) {
          $(parent).css('width',
              ($(window).width() - parent.offsetLeft - 3) + 'px');
          $(parent).children().each(function() {
            if (this.nodeName != "BUTTON") {
              $(this).css('width',($(window).width() - parent.offsetLeft) + 'px');
            }
          });
        }
      },

      _resizeBottomDialog: function(e, ae) {
        document.onselectstart = function () { return false; };
        
        var y = ae.pageY - $(window).scrollTop();

        var el = e.currentTarget;
        var parent = el.parentElement.parentElement;

        var resizedY = y - parent.offsetTop;

        if (resizedY < parent.originHeight) {
          resizedY = parent.originHeight;
        }

        $(parent).css('height', resizedY + 'px');
        if ($(parent).height() >=
          ($(window).height() - parent.offsetTop)) {
          $(parent).css('height',
              ($(window).height() - parent.offsetTop - 3) + 'px');
        }
      },

      _resizeBothDialog: function(e, ae) {
        $.alopexWidget.dialog._resizeRightDialog(e, ae);
        $.alopexWidget.dialog._resizeBottomDialog(e, ae);
      },
      
      _moveToTop: function(e) {
        var el = $('#'+this.id)[0];
        var dialog = $.alopexWidget.dialog;
        dialog.maxZindex = dialog.maxZindex +1;
        $(el).css('z-index', dialog.maxZindex);
        
        //To Fix IE7 z-index bug
        if(navigator.appVersion.indexOf("MSIE 7.")!=-1 || document.documentMode == "7"){
          var parentElem = $(el).parent();
          
          while($(parentElem).prop("tagName").toLowerCase() != 'html'){
            if($(parentElem).css('position') == 'relative'
              && $(parentElem)[0].tagName != "BODY" ){
              $(parentElem).css('position', 'static');
              break;
            }
            parentElem = $(parentElem).parent();
          }
        }
        
        if (el.modal) {
          $(el.blocker).css('z-index', dialog.maxZindex-3);
        }
      },

      open: function(jsonObject) {
        try {
          var el = this;
          var dialog = $.alopexWidget.dialog;
          
          //open check
          if ($(el).css('display') == 'block') {
            return;
          }
          
          var title ="";
          var top = null;
          var left = null;
          var dialogType = null;
          var resizable = null;
          var movable = null;
          var modal = null;
          var animation = null;
          var animationTime = null;
          if (jsonObject != null) {
            title = jsonObject.title;
            top = jsonObject.top;
            left = jsonObject.left;
            if (jsonObject.type != null) {
              dialogType = jsonObject.type.toLowerCase();
            }
            resizable = jsonObject.resizable;
            movable = jsonObject.movable;
            modal = jsonObject.modal;
            if (jsonObject.animation != null) {
              animation = jsonObject.animation.toLowerCase();
            }
            
            if (typeof(jsonObject.animationtime)=="string") {
              animationTime = Number(jsonObject.animationtime);
            } else {
              animationTime = jsonObject.animationtime;
            }
          }
          
          // set attribute
          if (dialogType != null) {
            $(el).children().remove();
            dialog._setDialogType(el, dialogType);
          }
          if (resizable != null) {
            $(el.footer).remove();
            dialog._setResizable(el, resizable);
          }
          
          if($(el).find('[data-dialog-movecursor=true]').length > 0){
            movable = true;
          }
          
          if (movable != null) {
            dialog._setMovable(el, movable);
          }
          if (modal != null) {
            dialog._setModal(el, modal);
          }
          if (animation != null) {
            el.animation = animation;
          }
          if (animationTime != null) {
            el.anitime = animationTime;
          }
          
          // set open button
          if($.alopexUtil.isValid(document.activeElement) && document.activeElement.tagName !== "BODY") {
            el.target = document.activeElement;
          } else if ($.alopexUtil.isValid(window.__lastAlopexEventElement)) {
            el.target = window.__lastAlopexEventElement;
          } else if ($.alopexUtil.isValid(window.event)) {
            el.target = window.event.srcElement;
          }
          
          if ($(el).children().length > 0) {
            if ($.alopexUtil.isValid(title)) {
              for (var i=0; i < $($(el).children()[0]).contents().length; i++) {
                if ($($(el).children()[0]).contents()[i].nodeType == 3) {
                  $(el).children()[0].removeChild($($(el).children()[0]).contents()[i]);
                }
              }
              $($(el).children()[0]).append(title);
            }
          }
          
          //open 시 body에 scroll이 있을 경우에만 disabled 적용
          if($(window).height() < $(document).height()){
            $('html').css('width', '100%');

            el.scrollPosition = $(window).scrollTop();

            if(navigator.appVersion.indexOf("MSIE 7.")!=-1 || document.documentMode == "7"){
              $('body').css('position', 'relative');
              $('body').css('overflow', 'hidden');
            }else{
              document.documentElement.style.overflowY = 'scroll';
              document.documentElement.style.position = 'fixed';
              
              //Android 4+ 삼성 기본브라우저에서 position fixed 적용 시 top, left도 함께 적용해야 함.
              if(window.browser == 'mobile'){
                document.documentElement.style.top = '0px';
                document.documentElement.style.left = '0px';
              }
            }
          }
          
          $(el).css('display', 'block');
          $(el).css('opacity', 1);

          // set dialog position
          if ($.alopexUtil.isValid(top)) {
            $(el).css('top', top + 'px');
          } else {
            var centerTop = ($(window).height() - el.offsetHeight) / 2;
            if(centerTop < 0){
              centerTop = 0;
            }
            $(el).css('top', (centerTop + window.afDialogNumber*10) + 'px');
          }
          if ($.alopexUtil.isValid(left)) {
            $(el).css('left', left + 'px');
          } else {
            var centerLeft = ($(window).width() - el.offsetWidth) / 2;
            $(el).css('left', (centerLeft + window.afDialogNumber*10) + 'px');
          }

          if (el.modal) {
            $(el.blocker).css('height', $(document).height() + 'px');
            $(el.blocker).css('width', $(document).width() + 'px');
            $(el.blocker).css('display', 'block');
          }
          
          dialog.id = el.id;
          dialog._moveToTop();

          window.afDialogNumber++;

          $(window).bind('resize', dialog._reposition);
          
          //IE10에서 호환성 보기로 로드 할 경우 tabindex를 0으로 지정 후 focus()시 에러 발생하는 브라우저 버그 처리
          if(navigator.userAgent.toLowerCase().indexOf('trident/6.0') == -1){
            $(el).attr("tabindex", 0);
          }
          $(el).focus();
          
          //IE일 경우 Dialog focus 라인 제거(호환성 보기로 할 경우 잔상 생김)
          if(window.browser == "ie"){
            $(el).attr("hideFocus", "true").css("outline", "none");
            
            //IE에서 html position fixed와 window.print()를 함께 사용할 시 에러 수정.  
            window.onbeforeprint = function (){
              $('html').css('position', 'static');
            };
            window.onafterprint = function (){
              if(window.afDialogNumber != undefined && window.afDialogNumber > 0){
                $('html').css('position', 'fixed');
              }
            };
          }
        } catch (e) {
          throw new Error(e);
        }
      },
      
      ok: function(callback) {
        $('#' + this.id + '_ok').bind('tap', callback);
      },

      cancel: function(callback) {
        $('#' + this.id + '_cancel').bind('tap', callback);
      },

      confirm: function(callback) {
        $('#' + this.id + '_confirm').bind('tap', callback);
      },
      
      close: function(callback) {
        var el = this;
        var dialog = $.alopexWidget.dialog;
        
        if($(el).css('display') != 'block'){
          return;
        }
        
        if (callback != null) {
          $('#' + el.id + '_close').bind({
            'tap': function() {
              callback();
            }
          });
          return;
        }

        if (window.afDialogNumber <= 0) {
          window.afDialogNumber = 0;
        } else {
          window.afDialogNumber--;
        }
        $('#' + el.id).css('z-index', 1000);
        if (window.afDialogNumber == 0) {
          dialog.maxZindex = 1000;
          
          if(navigator.appVersion.indexOf("MSIE 7.")!=-1 || document.documentMode == "7"){
            $('body').css('position', '');
            $('body').css('overflow', '');
          }else{
            document.documentElement.style.overflowY = '';
            document.documentElement.style.position = '';
          }
          
          $(window).scrollTop(el.scrollPosition);
          $(document.body).css('position', '');
        }
        
        if (el.animation != null) {
          switch (el.animation) {
          case 'slide':
            $(el).slideUp(el.anitime, function(e) {
              if (el.modal) {
                $(el.blocker).css('display', 'none');
              }
              $(el).css('display', 'none');
            });
            break;
          case 'fade':
            $(el).fadeOut(el.anitime, function(e) {
              if (el.modal) {
                $(el.blocker).css('display', 'none');
              }
              $(el).css('display', 'none');
            });
            break;
          default:
            $(el).hide(el.anitime, function(e) {
              if (el.modal) {
                $(el.blocker).css('display', 'none');
              }
              $(el).css('display', 'none');
            });
          break;
          }
        } else {
          //mobile device에서 close 시 뒤의 버튼 클릭 방지.
          if(window.browser == 'mobile'){
            setTimeout(function (){
              if (el.modal) {
                $(el.blocker).css('display', 'none');
              }
              $(el).css('display', 'none');
            },500);
          }else{
            if (el.modal) {
              $(el.blocker).css('display', 'none');
            }
            $(el).css('display', 'none');
          }
        }
        
        $(window).unbind('resize', dialog._reposition);

        $('#' + el.id + '_ok').unbind('tap');
        $('#' + el.id + '_cancel').unbind('tap');
        $('#' + el.id + '_close').unbind('tap');
        $('#' + el.id + '_confirm').unbind('tap');
        
        if ($.alopexUtil.isValid(el.target)) {
          $(el.target).focus();
        }
      },

      _reposition: function(e) {
        e.preventDefault();
        var jObj = $('#' + $.alopexWidget.dialog.id);
        var el = jObj[0];

        if (el != undefined && !el.resizable && !el.movable) {
          var centerTop = ($(window).height() - el.offsetHeight) / 2;
          if(centerTop < 0){
            centerTop = 0;
          }
          $(el).css('top', (centerTop + window.afDialogNumber * 10) + 'px');
          var centerLeft = ($(window).width() - el.offsetWidth) / 2;
          $(el).css('left', (centerLeft + window.afDialogNumber * 10) + 'px');
        }
        
        if (el != undefined && el.modal) {
          $(el.blocker).css('height', $(document).height() + 'px');
          $(el.blocker).css('width', $(document).width() + 'px');
        }
      },
      
      reposition: function() {
        var el = this;
        
        if (el != undefined) {
          var centerTop = ($(window).height() - el.offsetHeight) / 2;
          if(centerTop < 0){
            centerTop = 0;
          }
          $(el).css('top', (centerTop + window.afDialogNumber * 10) + 'px');
          var centerLeft = ($(window).width() - el.offsetWidth) / 2;
          $(el).css('left', (centerLeft + window.afDialogNumber * 10) + 'px');
        }
        
        if (el != undefined && el.modal) {
          $(el.blocker).css('height', $(document).height() + 'px');
          $(el.blocker).css('width', $(document).width() + 'px');
        }
      },

      id: {
        value: null,
        enumerable: true,
        configurable: false,
        writable: true
      }
    },

    textinput: {
      textinput: function(options) {
        var el = this;
        $.alopexWidget.object.addDefaultStyleClass(el, 'af-textinput');
        $.alopexWidget.object.addHighlight(el);
        
        if ($.alopexUtil.isValid($(el).attr('data-disabled')) && $.alopexUtil.parseBoolean($(el).attr('data-disabled'))) {
          el.enabled = false;
        } else {
          el.enabled = true;
        }
        
        if (!el.enabled) {
          $(el).setEnabled(el.enabled);
        }
      },

      _edit: function(e) {
        var el = e.target;
        el.focus();
        $(el).removeAttr('disabled');
        $(el).bind('focusout', function(e) {
          $(el).attr('disabled', 'disabled');
        });
      },

      setEnabled: function(boolean) {
        var el = this;
        el.enabled = boolean;
        
        if (el.enabled) {
          $(el).removeAttr('readonly');
          $.alopexWidget.object._removeDisabledStyle(el);
        } else {
          $(el).attr('readonly', 'true');
          $.alopexWidget.object._addDisabledStyle(el);
        }
      }
    },

    list: {
      list: function(options) {
        var el = this;
        var $ob = $.alopexWidget.object;
        $ob.addDefaultStyleClass(el, 'af-list');
        $.alopexWidget.list.refresh(el);
      },
      
      refresh: function(el) {
        if(el == undefined) {
          el = this;
        }
        var $ob = $.alopexWidget.object;
        var rows = $(el).find('>li');
        for (var i = 0; i < rows.length; i++) {
          var row = rows[i];
          if( $(row).attr('data-converted') == 'true')
            continue;
          
          $(row).bind('singletap', function(e) {
            var target = e.currentTarget;
            $(target).siblings('li').removeClass('af-selected');
            $(target).addClass('af-selected');
          });
          
          if ($(row).attr('data-type') == 'divider') {
//            $ob.addDefaultStyleClass(row, 'af-list-divider');
            $(row).addClass('af-list-divider');
            continue;
          } else {
//            $ob.addDefaultStyleClass(row, 'af-list-row');
            $(row).addClass('af-list-row');
          }

          // 이미지(thumbnail 처리)
          var img = undefined;
          if ($(row).find('img').length == 1) {
            img = $(row).find('img')[0];
            if($.alopexUtil.parseBoolean($(img).attr('data-icon'))) {
//              $ob.addDefaultStyleClass(img, 'af-list-thumbnail-icon');
              $(img).addClass('af-list-thumbnail-icon');
            } else {
              $ob.addDefaultStyleClass(img, 'af-list-thumbnail');
//              $(img).addClass('af-list-thumbnail');
            }
          }

          // Title
          $(row).find('h1, h2, h3').each(function() {
//            $ob.addDefaultStyleClass(this, 'af-list-title');
            $(this).addClass('af-list-title');
            
          });

          var icon = $(row).find('[data-icon]');
          if (icon.length > 0) {
            icon.each(function() {
              $ob.addDefaultStyleClass(this,
                  'af-list-icon af-list-icon-' + $(this).attr('data-icon'));
            });
          }

          var btn = $(row).find('a');
          if (btn.length > 0) {
            $.alopexWidget.object.addHighlight(row);
          }
          if (btn.length == 1) {
            $ob.addDefaultStyleClass(btn[0], 'af-list-btn');
          } else if (btn.length == 2) {
            $ob.addDefaultStyleClass(btn[0], 'af-list-btn');
            $ob.addDefaultStyleClass(btn[1], 'af-list-btn split');
            $.alopexWidget.object.addHighlight(btn[1]);
          }

          // accordian code
          if (rows[i].getAttribute('data-id')) {
            rows[i].className += ' af-accordion';
            var accordianId = rows[i].getAttribute('data-id');
            $(el).find('#' + accordianId).css('display', 'none');
            $(rows[i]).bind('click', function(e) {
              var row = e.currentTarget;
              $.alopexWidget.list.toggle(row);
            });
          }

          var rowHeight = row.offsetHeight;
          var textblock = document.createElement('div');  // text 영역 wrapper.
          $(textblock).attr('class', 'af-list-text')
//            .css('height', rowHeight);
          if (img) {
            var siblings = img.parentNode.childNodes;
            for (var j = 0; j < siblings.length; ) {
              if (siblings[j] == img) {
                j++;
                continue;
              }
              $(siblings[j]).appendTo(textblock);
            }
            $(textblock).insertAfter(img);
          } else if (btn && btn.length > 0) {
            var children = btn[0].childNodes;
            for (var j = 0; j < children.length; j) {
              $(children[j]).appendTo(textblock);
            }
            $(textblock).appendTo(btn[0]);
          } else {
            var children = row.childNodes;
            for (var j = 0; j < children.length; j) {
              $(children[j]).appendTo(textblock);
            }
            $(textblock).appendTo(row);
          }
          $(row).attr('data-converted', 'true')
        }
      },

      toggle: function(row) {
        function toggle(el, id) {
          if ($(el).find('#' + id).css('display') == 'none') {
            $(el).find('#' + id).css('display', 'block');
          } else {
            $(el).find('#' + id).css('display', 'none');
          }
        }
        if (row.getAttribute('data-id')) {
          var el = row.parentNode;
          var accordianId = row.getAttribute('data-id');
          // $(el).find("#" + accordianId).toggle(500);
          var rows = $(el).find('>li');
          // single accordion can be expanded
          if ($.alopexUtil.parseBoolean(el.getAttribute('data-single-expand'))) {
            for (var i = 0; i < rows.length; i++) {
              if (rows[i].getAttribute('data-id')) {
                var tmpId = rows[i].getAttribute('data-id');
                if (tmpId == accordianId) {
                  toggle(el, tmpId);
                } else {
                  $(el).find('#' + tmpId).css('display', 'none');
                }
              }
            }
          } else {
            toggle(el, accordianId);
          }

        }
      },

      setEnabled: function(boolean) {
        var element = this;

        if (boolean) {
          for (var i = 0; i < element.children.length; i++) {
            var child = element.children[i];

            if (child.tagName == 'a') {
              $('#' + child.id).css('cursor', '');
              $('#' + child.id).css('pointer-events', '');
            } else {
              $('#' + child.children[0].id).css('cursor', '');
              $('#' + child.children[0].id).css('pointer-events', '');
            }
          }
        } else {
          for (var i = 0; i < element.children.length; i++) {
            var child = element.children[i];

            if (child.tagName == 'a') {
              $('#' + child.id).css('cursor', 'default');
              $('#' + child.id).css('pointer-events', 'none');
            } else {
              $('#' + child.children[0].id).css('cursor', 'default');
              $('#' + child.children[0].id).css('pointer-events', 'none');
            }
          }
        }
      }
    },

    panel: {
      panel: function(options) {
        var el = this;
        $.alopexWidget.object.addDefaultStyleClass(el, 'af-panel');
        if (el.getAttribute('data-fill') != undefined) {
          $.alopexWidget.panel._fill(el);
        }
        if ($.alopexUtil.parseBoolean(el.getAttribute('data-scroll'))) {
          $.alopexWidget.panel._makeScrollable(el);
        }
        $(window).bind('resize', $.alopexWidget.panel._resize);
        
        if($(el).attr('data-responsive') != undefined) {
          $(el).css('float', 'left').css('width', '100%');
          $(window).bind('resize', $.alopexWidget.panel._responsive);
          $.alopexWidget.panel._responsive();
        }
      },

      _responsive: function() {
        $("[data-responsive]").each(function() {
          var el = this;
          var width = 100;
          var parentWidth = parseFloat($(el).attr('data-responsive').split('-')[0]);
          var panelWidth = parseFloat($(el).attr('data-responsive').split('-')[1]);
          var clientWidth = document.documentElement.clientWidth;
          
          if(clientWidth <= $.alopex.responsive.threshold) {
            
          } else if (clientWidth > $.alopex.responsive.threshold && clientWidth <= 900) {
            width = panelWidth / parentWidth * 100;
          } else {
            width = panelWidth / parentWidth * 100;
          }
          $(el).css('width', width + '%');
        });
      },

      _makeScrollable: function(el) {
        try {
//          var el = this;
          if (window.browser == 'mobile') {
            var iScrollOption = {};
            if ((/iphone|ipad/gi).test(navigator.appVersion)) {
              iScrollOption.useTransform = true;
            } else {

              if ($(el).find('input').length > 0 ||
                  $(el).find('textarea').length > 0) {
                iScrollOption.useTransform = false;
              } else {
                iScrollOption.useTransform = true;
              }
            }
            iScrollOption.onBeforeScrollStart = function(e) {
              var target = e.target;
              while (target.nodeType != 1)
                target = target.parentNode;

              if (target.tagName != 'SELECT' && target.tagName != 'INPUT' &&
                  target.tagName != 'TEXTAREA')
                e.preventDefault();
            };
            iScrollOption.checkDOMChanges = true;
            el.style.position = 'relative';
            el.scroll = new iScroll(el, iScrollOption);
            el.scroll.onScrollEnd = function(e) {
              $(el).trigger('scrollend', e);
            };
          } else {
            // For IE7.
            $(el).css('position', 'relative');
            $(el).css('overflow', 'auto');
            if (el.children.length >= 1) {
              if (el.offsetHeight < el.children[0].offsetHeight) {
                $(el).css('overflow-y', 'scroll');
              }
              if (el.offsetWidth < el.children[0].offsetWidth) {
                $(el).css('overflow-x', 'scroll');
              }
            }
          }
        } catch (e) {
          throw new Error('[makeScrollable] ' + e);
        }
      },
      
      scrollToElement: function(selector, time) {
        var el = this;
        if (window.browser == 'mobile') {
          el.scroll.scrollToElement(selector, time);
        } else {
          if($(el).find(selector).length > 0) {
            el.scrollTop = $(el).find(selector)[0].offsetHeight;
          }
          
        }
      },

      _resize: function(e) {
        $("[data-type='panel']").refresh();
      },

      refresh: function() {
        var el = this;
        if (el.getAttribute('data-fill') != undefined) {
          $.alopexWidget.panel._fill(el);
        }
        if ($.alopexUtil.parseBoolean(el.getAttribute('data-scroll'))) {
          $.alopexWidget.panel._scroll_refresh(el);
        }
      },

      _scroll_refresh: function(el) {
        if (el.scroll) {
          el.scroll.refresh();
        } else {
          $(el).css('overflow', 'auto');
          if (el.children.length >= 1) {
            if (el.offsetHeight < el.children[0].offsetHeight) {
              $(el).css('overflow-y', 'scroll');
            }
            if (el.offsetWidth < el.children[0].offsetWidth) {
              $(el).css('overflow-x', 'scroll');
            }
          }
        }
      },

      _fill: function(el) {
        var setting = el.getAttribute('data-fill');
        var tmp = el.style.display;
        el.style.display = 'none';
        switch (setting) {
        case 'vertical':
          $.alopexWidget.object.fillVertical(el);
          break;
        case 'horizontal':
          $.alopexWidget.object.fillHorizontal(el);
          break;
        case 'both':
          $.alopexWidget.object.fillVertical(el);
          $.alopexWidget.object.fillHorizontal(el);
        default:
          break;
        }
        el.style.display = tmp;
      }
    },

    radio: {
      radio: function(options) {
        var el = this;
        $.alopexWidget.object.addDefaultStyleClass(el, 'af-radio');
        
        var date = new Date();
        if ($(el).attr('id') == null) {
          $(el).attr('id', 'a' + (date.getTime() + Math.floor(Math.random() * 1000000) + 1));
        }
        
        if ($.alopexUtil.isValid($(el).attr('data-disabled')) && $.alopexUtil.parseBoolean($(el).attr('data-disabled'))) {
          el.enabled = false;
        } else {
          el.enabled = true;
        }
        
        if (!el.enabled) {
          $(el).setEnabled(el.enabled);
        }
      },
      
      setSelected: function() {
        var el = this;

        if (el.tagName == 'INPUT') {
          el.checked = true;
        }
      },

      getValue : function() {
        var el = this;

        var radioList = $("input[name=" + el.name + "]:checked");
        if (radioList.length > 0) {
            return $(radioList[0]).val();
        }
        return null;
      },

      getText: function() {
        var el = this;
        
        var radioList = $("input[name=" + el.name + "]:checked");
        if (radioList.length > 0) {
          var obj = radioList[0];
          var elId = $(obj).attr('id');
          var el_label = $(el).parent().find("label[for=\'" + elId + "\']");
          
          return $(el_label).text();
        }
        return null;
      },
      
      setEnabled: function(boolean) {
        var el = this;
        el.enabled = boolean;
        var elId = $(el).attr('id');
        var el_label = $(el).parent().find("label[for=\'" + elId + "\']");

        if (el.enabled) {
          $(el).removeAttr('disabled');
          $.alopexWidget.object._removeDisabledStyle(el);
          $.alopexWidget.object._removeDisabledStyle(el_label);
          
        } else {
          $(el).attr('disabled', 'disabled');
          $.alopexWidget.object._addDisabledStyle(el);
          $.alopexWidget.object._addDisabledStyle(el_label);
        }
      }
    },

    select: {
      select: function(options) {
        try {
          var el = this;
          el.originWidth = $(el).width();
          
          if (el.tagName.toLowerCase() != 'select') { // el node only buttonize
            return;
          }

          var date = new Date();
          if ($(el).attr('id') == null) {
            $(el).attr('id', 'a' + (date.getTime() + Math.floor(Math.random() * 1000000) + 1));
          }
          
          if ($.alopexUtil.isValid($(el).attr('data-select-multiple')) &&
              $.alopexUtil.parseBoolean($(el).attr('data-select-multiple'))) {
            el.multi = true;
          } else {
            el.multi = false;
          }
          
          if (el.multi) {
            $(el).attr('multiple', 'multiple');

            $.alopexWidget.object.addDefaultStyleClass(el, 'af-multiselect');

            $(el).bind('selectstart', function(e) {
              return false;
            });
            $(el).bind('change', $.alopexWidget.select._change);
          } else {
            $.alopexWidget.object.addDefaultStyleClass(el, 'af-select');

            //data-placeholder
            if ($.alopexUtil.isValid($(el).attr('data-placeholder'))) {
              $(el).prepend('<option value="" selected="selected" disabled>' + $(el).attr('data-placeholder') + '</option>');
              $(el)[0].options[0].selected = true;
              el.originWidth = $(el).width();
            }
          }

          if ($.alopexUtil.isValid($(el).attr('data-disabled')) && $.alopexUtil.parseBoolean($(el).attr('data-disabled'))) {
            el.enabled = false;
          } else {
            el.enabled = true;
          }
          
          if (!el.enabled) {
            $(el).setEnabled(el.enabled);
          }
        } catch (e) {
        }
      },

      setSelected: function(text) {
        // check null
        if (this.children.length == 0) {
          return;
        }
        
        var flag = true;
        for (var i = 0; i < this.children.length; i++) {
          if (this.children[i].text == text) {
            $(this.children[i]).attr('selected', 'selected');
            //this.textfield.innerHTML = text;
            flag = false;
          }
        }
        if (flag) {
          for (var i = 0; i < this.children.length; i++) {
            if (this.children[i].value == text) {
              $(this.children[i]).attr('selected', 'selected');
              //this.textfield.innerHTML = this.children[i].text;
            }
          }
        }
      },
      
      getValues: function() {
        var el = this;
        var tmpValuesArr = [];
        if (el.multi) {
          $('#' + el.id +' option:selected').each(function () {
            tmpValuesArr.push($(this).val());
          });
          return tmpValuesArr;
        } else {
          return $('#' + el.id +' :selected').val();
        }
      },
      
      getTexts: function() {
        var el = this;
        var tmpTextsArr = [];
        if (el.multi) {
          $('#' + el.id +' option:selected').each(function () {
            tmpTextsArr.push($(this).text());
          });
          return tmpTextsArr;
        } else {
          return $('#' + el.id +' :selected').text();
        }
      },

      setEnabled: function(bool) {
        var el = this;
        el.enabled = bool;
        
        if (el.enabled) {
          $(el).removeAttr('disabled');
          $.alopexWidget.object._removeDisabledStyle(el);
        } else {
          $(el).attr('disabled', 'disabled');
          $.alopexWidget.object._addDisabledStyle(el);
        }
      }
    },

    textarea: {
      textarea: function(options) {
        var el = this;
        $.alopexWidget.object.addDefaultStyleClass(el, 'af-textarea');
        //$.alopexWidget.object.addHighlight(el);
        /*$(el).on('hoverstart focusin', $.alopexWidget.object._addHoverStyle);
        $(el).on('hoverend focusout', $.alopexWidget.object._removeHoverStyle);*/
        
        if ($.alopexUtil.isValid($(el).attr('data-disabled')) && $.alopexUtil.parseBoolean($(el).attr('data-disabled'))) {
          el.enabled = false;
        } else {
          el.enabled = true;
        }
        
        if (!el.enabled) {
          $(el).setEnabled(el.enabled);
        }
      },

      _edit: function(e) {
        var el = e.target;
        el.focus();
        $(el).removeAttr('disabled');
        $(el).bind('focusout', function(e) {
          $(el).attr('disabled', 'disabled');
        });
      },

      setEnabled: function(boolean) {
        var el = this;
        el.enabled = boolean;
        
        if (el.enabled) {
          $(el).removeAttr('readonly');
          $.alopexWidget.object._removeDisabledStyle(el);
        } else {
          $(el).attr('readonly', 'readonly');
          $.alopexWidget.object._addDisabledStyle(el);
        }
      }
    },

    scrollview: {
      scrollview: function(options) {
        try {
          var el = this;

          $.alopexWidget.panel.refresh.apply(el);

          if (window.browser == 'mobile') {

            var iScrollOption = {};
            if ((/iphone|ipad/gi).test(navigator.appVersion)) {
              iScrollOption.useTransform = true;
            } else {

              if ($(el).find('input').length > 0 ||
                  $(el).find('textarea').length > 0) {
                iScrollOption.useTransform = false;
              } else {
                iScrollOption.useTransform = true;
              }
            }
            iScrollOption.onBeforeScrollStart = function(e) {
              var target = e.target;
              while (target.nodeType != 1)
                target = target.parentNode;

              if (target.tagName != 'SELECT' && target.tagName != 'INPUT' &&
                  target.tagName != 'TEXTAREA')
                e.preventDefault();
            };
            iScrollOption.checkDOMChanges = true;
            el.style.position = 'relative';
            el.scroll = new iScroll(el, iScrollOption);
            $(window).bind('resize', function(e) {
              try {
                el.scroll.refresh();
              } catch (e) {
                throw new Error(e);
              }
            });
          } else {
            // TO fix IE7 Bug. Without this statement,
            // scroll content will be visible.
            $(el).css('position', 'relative');
            $(el).css('overflow', 'hidden');
            if (el.children.length >= 1) {
              if (el.offsetHeight < el.children[0].offsetHeight) {
                $(el).css('overflow-y', 'scroll');
              }
              if (el.offsetWidth < el.children[0].offsetWidth) {
                $(el).css('overflow-x', 'scroll');
              }
            }
          }
        } catch (e) {
          throw new Error('scroll create === ' + e);
        }
      },

      refresh: function() {
        var el = this;
        if (el.scroll) {
          el.scroll.refresh();
        } else {
          if (el.offsetHeight < el.children[0].offsetHeight) {
            $(el).css('overflow-y', 'scroll');
          }
          if (el.offsetWidth < el.children[0].offsetWidth) {
            $(el).css('overflow-x', 'scroll');
          }
        }
        $.alopexWidget.panel.refresh.apply(el);

      }
    },

    tabs: {

      tabs: function() {
        try {
          var el = this;
          el.eventState= "init";
          var $af = $.alopexWidget.object;
          $af.addDefaultStyleClass(el, 'af-tabs');
          var event = 'tap';
          
          var buttons = $(el).find('> a');
          if ($(el).attr('data-event') == 'hover') {
            event = 'hover';
          }
          buttons.bind('click', function(e) {
            e.preventDefault(); // stop navigating to "ajax loding page"
          });
          if (buttons.length > 0) {
            
            el.buttonWrapper = document.createElement('div'); // button Wrapper
            $(el.buttonWrapper).insertBefore(buttons[0]);
            $af.addDefaultStyleClass(el.buttonWrapper, 'af-tabs-button-group');
            
            el.contentWrapper = document.createElement('div'); // content Wrapper
            if($(el).attr('data-position') == 'bottom') {
              $(el).prepend(el.contentWrapper);
            } else {
              $(el).append(el.contentWrapper);
            }
            
            $(el.contentWrapper).attr('data-type', 'panel')
              .attr('data-fill', 'vertical');

            for (var i = 0; i < buttons.length; i++) {
              var tabButton = buttons[i];
              tabButton.index = i;
              $(tabButton).appendTo(el.buttonWrapper);
              $.alopexWidget.object.addHighlight(tabButton);
              $af.addDefaultStyleClass(tabButton, 'af-tabs-button');
              $(tabButton).find('img').addClass('af-tabs-button-icon');
              var linktabButton = (tabButton.tagName.toLowerCase() == 'a') ?
                  $(tabButton) : $(tabButton).find('a');
              var address = linktabButton.attr('href').split('#');

              if(address.length == 1) { // 
                tabButton.loadType = 'ajax';
              } else if(address.length == 2) { //
                if(address[0] == '' || address[0] == document.URL.split('#')[0]) {
                  tabButton.loadType = 'local';
                  tabButton.hashAddr = address[1];
                } else {
                  tabButton.loadType = 'ajax';
                }
              }

              switch(tabButton.loadType) {
              case 'local':
                tabButton.content = $(el).find('#' + tabButton.hashAddr)[0];
                break;
              case 'ajax':
                tabButton.content = document.createElement('div');
                $(tabButton.content).appendTo(el);
                break;
              default:
                break;
              }
              $(tabButton.content).appendTo(el.contentWrapper);
              
              // add event handler for tab change
              $(tabButton).bind(event, function (e) {
                try {
                  var tabBtn = e.target;
                  while (tabBtn.index == undefined) {
                    tabBtn = tabBtn.parentNode;
                  }
                  tabBtn.defaultStyleClass = $(tabBtn).attr('class');
                  $.alopexWidget.tabs.setTabIndex(tabBtn.index, el); // 계속 되겠ㄴ
                  el.eventState= "focused";
                } catch (e) {
                  throw new Error("[tabs Handler] " + e);
                }
              });
            }
          }
          if(false) {
            $(el.contentWrapper).panel();
          }
          $.alopexWidget.tabs.setTabIndex(0, el);
        }catch (e) {
          throw new Error('[tabs] ' + e);
        }
      },
      
      _focusEventHandler : function(e){
        var el = $(e.currentTarget).parents('[data-type="tabs"]')[0];
        el.eventState= "focused";
        $.alopexWidget.tabs._addKeyEvent(el);
      },
      
      /**
       * the event handler when tab button got blured.
       * TODO : 1. bind focus events
       *        2. unbind keyboard event
       * @param el
       */
      _addFocusEvent: function (el) {
        var tabButton = $(el).find('.af-selected');
        el.selected = tabButton[0];
        $(window).unbind('keydown', $.alopexWidget.tabs._keyEventHandler);
        tabButton.bind('focus', $.alopexWidget.tabs._focusEventHandler);
        el.eventState= "blured";
      },
      
      /**
       * the event handler when tab button got focused.
       * TODO : 1. unbind focus events
       *        2. bind keyboard event
       * @param el
       */
      _addKeyEvent: function(el) {
        $(window).bind('keydown', $.alopexWidget.tabs._keyEventHandler);
        $(el.selected).unbind('focus', $.alopexWidget.tabs._focusEventHandler);
      },
      
      _keyEventHandler: function(e) {
        var target = e.target;
        
        switch(e.which) {
        case 9: // tab
          $.alopexWidget.tabs._addFocusEvent($(target).parents('div[data-type="tabs"]')[0]);
          return;
        case 37:
        case 38:
          if($(target).prev().length != 0) {
            target = $(target).prev()[0];
          } else {
            target = $(target).siblings().last()[0];
          }
          break;
          
        case 39:
        case 40:
          if($(target).next().length != 0) {
            target = $(target).next()[0]; 
          } else {
            target = $(target).siblings().first()[0];
          }
          break;
        default:
          return;
        }
        $.alopexWidget.tabs.setTabIndex(target.index, $(target).parents('div[data-type="tabs"]')[0]);
        target.focus();
        e.preventDefault();
      },
      

      setTabIndex: function(index, el, eventFlag) {
        try {
          if (el == undefined) {
            el = this; // API Call
          }
          
          if (el.buttonWrapper) {
            var buttons = el.buttonWrapper.children;
            for (var i = 0; i < buttons.length; i++) {
              if (i == index) { 
                if(buttons[i].loadType == 'ajax') {
                  var tmpContent = buttons[i].content;
                  $(buttons[i].content).load($(buttons[i]).attr('href'), function(response, status, xhr) {
                    if(status == 'error') {
                      var msg = '<p>Sorry, there was an ERROR!</p>' +
                        '<p style="color:red;">' + xhr.status + '<br/>' + xhr.statusText + '</p>';
                      $(tmpContent).html(msg);
                    } else {
                      $.alopex.convert(tmpContent);
                    }
                    
                  });
                }
                $(buttons[i].content).css('display', 'block');
                $(buttons[i]).attr('aria-selected', 'true')
                             .attr('tabindex', '0')
                             .addClass('af-selected');
                
              } else {
                $(buttons[i].content).css('display', 'none');
                $(buttons[i]).attr('aria-selected', 'false')
                             .attr('tabindex', '-1')
                             .removeClass('af-selected');
              }
            }
          }
          
          // setTabIndex can be executed in 2 cases.
          // 1. when tab is initialized. should be called _addFocusEvent.
          // 2. when a tab button is clicked or hovered. should be called _addKeyEvent.
          // 3. when a tab button is chosen by arrow button. do NOTHING!!
          if(el.eventState == "init") {
            $.alopexWidget.tabs._addFocusEvent(el);
          } else if(el.eventState != "focused") {
            $.alopexWidget.tabs._addKeyEvent(el);
          }
          
        } catch (e) {
          throw new Error('[tabs-setTabIndex] ' + e);
        }
      }

    },


    table: {
      
      table: function(options) {
            try {
              var el = this;
              var $el = $(el);
              
              $.extend(el, {
                wrapper: null,
                scroller: null,
                head: null,
                scrolling: false,
                sorting: false,
                resizing: false,
                editing: false,
                highlighting: false,
                resizingHeader: null,
                theme: null
              });
              
              $.alopexWidget.object.addDefaultStyleClass(el, 'af-table');
              $.alopexWidget.table._addColgroup(el);
              $el.css({"width": "100%", "table-layout": "fixed"});
              
              el.head = $.alopexWidget.table.getTableHead(el);
              el.head.table = el; // 헤더가 나눠지더라도 테이블 참조할 수 있도록.
              $(el.head).attr('class', 'af-table-head');
              $wrapper = $('<div></div>').attr('class', 'af-table-wrapper ' + el.theme);
              $el.wrap($wrapper[0]);
              el.wrapper = el.parentNode;
              
              $.alopexWidget.table.refresh(el);
            } catch (e) {
              throw new Error('[table] ' + e);
            }
          },
          
          refresh: function(el) {
            if(el == undefined) {
              el = this;
            }
            $el = $(el);
            $table = $.alopexWidget.table;
            $.alopex.convert(el);
    
            if(navigator.userAgent.indexOf('MSIE 7') != -1) {
              $el.removeAttr('data-scroll');
            }
            
            if (!el.sorting && $el.find("[data-sortable]").length > 0) {
              $.alopexWidget.table._enableSorting(el);
              el.sorting = true;
            }
            if (!el.resizing && $el.find("[data-resizable='true']").length > 0) {
              $.alopexWidget.table._enableResizing(el);
              el.resizing = true;
            }
            $(el).find("[data-editable='true']").addClass('af-table-editor');
            if (!el.editing && $el.find("[data-editable='true']").length > 0) {
              $.alopexWidget.table._enableEditing(el);
              el.editing = true;
            }
            if (!el.highlighting && $el.attr("data-highlight") == "true") {
              $el.css('cursor', 'pointer');
              $(el.wrapper).delegate('td,th', 'tap', $.alopexWidget.table._addTableHighlight);
              el.highlighting = true;
            }
            if(!el.scrolling && $el.attr('data-scroll') != undefined) {
              $.alopexWidget.table._enableScrolling(el);
              el.scrolling = true;
            }
    
            if ($.alopexUtil.isValid($(el).attr('data-height'))) {
              $(el.wrapper).css('height', $(el).attr('data-height'));
            }
            if ($.alopexUtil.isValid($(el).attr('data-width'))) {
              $(el).css('width', $(el).attr('data-width'));
            }
            
            if ($(el).attr("data-scroll") != undefined) {
              $.alopexWidget.table._refreshTableScroll(el);
            }
          },
    
          
          /**
           * Add div for scrolling functionality
           * @param el
           */
          _enableScrolling : function (el) {
            $scroller = $('<div></div>').attr('class', el.theme + ' af-table-scroller');
            $scroller.css({'overflow':'auto', '-webkit-overflow-scrolling':'touch'});
            $(el).wrap($scroller[0]);
            el.scroller = el.parentNode;
            $(el.wrapper).css('overflow', 'hidden'); // 가로 스크롤의 경우, 
            if($(el).attr('data-scroll') == 'body') {
    //          if(true) {
              if(window.browser == "mobile") {
                el.fake= $(el).clone(true).removeAttr('data-type').empty()[0];
                $(el.wrapper).prepend(el.fake);
                $(el.head).appendTo(el.fake);
                $(el.head).css({"position": "absolute"});
              } else {
                $(el.head).css({"float":"left", "position": "absolute", "top": "0px", "display": "inline-block", '-webkit-transform':"translate3d(0,0,0)"});
              }
              
              $(el.scroller).bind('scroll mousewheel', function(e){ // 가로 스크롤 시, 헤더 너비 조정.
                var target = e.currentTarget;
                var el = target.children[0];
                $(el.head).css({'left': (target.scrollLeft*-1) + 'px'});
              });
            }
            
            // flexbox 사용시 스타일 조정.
            $(el.wrapper).css({"display": "-webkit-box", "-webkit-box-flex": "1", "-webkit-box-orient": "vertical"});
            $(el.scroller).css({"display": "-webkit-box", "-webkit-box-flex": "1", "height": "100%", "-webkit-box-orient": "vertical"});
          },
          
          _refreshTableScroll: function(el) {
            /**
             * todo
             * 1. header size adjustment
             * 2. scroller height adjustment
             */
            var $scroller = $(el.scroller);
            
            if ($(el).attr("data-scroll") == 'all') {
              $scroller.css('margin-top', '0');
              
            } else {
              // header size adjustment
              var $head = $(el.fakehead).add(el.head);
              var cells = $(el).find('tr:last').find('td');
              
              $(el.fake).css({'display':'block', 'width': el.offsetWidth});
              $head.css('width', el.offsetWidth);
              for(var i=0; i<cells.length; i++) {
                var width = cells[i].offsetWidth;
                $head.find('th:nth-child(' + (i+1) + '), ' + 'td:nth-child(' + (i+1) + ')').css('width', width+'px');
              }
              $scroller.css('margin-top', el.head.offsetHeight + 'px');
            }
            
            // scroller size adjustment
            $scroller.css('height', $(el).attr('data-height'));
          },
          
          hideColumn: function (index) {
            var el = this;
            $(el).find('col:nth-child(' + (index + 1) + ')')
              .addClass('af-hidden');
          },
          
          showColumn: function (index) {
            var el = this;
            $(el).find('col:nth-child(' + (index + 1) + ')')
              .removeClass('af-hidden');
          },
          
          setColumnToggleButton: function(btn, modal, coordinate) {
            var el = this;
            el.toggleDialog = $('<div data-type="dialog" class="af-table-dialog"' + 
                (modal?' data-dialog-modal="true"' : '') + '></div>').appendTo('body').dialog()[0];
            var list = $('<ul data-type="list" class="list"></ul>').appendTo(el.toggleDialog)[0];
            var heads = el.rows[0].cells;
            for(var i=0; i<heads.length; i++) {
              if(heads[i].getAttribute('data-priority') != undefined) {
                var li = $('<li class="listrow"></li>').appendTo(list)[0];
                var a = $('<a></a>').appendTo(li).bind('tap', function(e) {
                  if(e.target.tagName.toLowerCase != 'input' && e.target.type != 'checkbox') {
                    var checkbox = $(e.currentTarget).find('input[type="checkbox"]');
                    if(checkbox.attr('checked') == undefined) {
                      checkbox.attr('checked', 'checked');
                    } else {
                      checkbox.removeAttr('checked');
                    }
                    checkbox.trigger('change');
                  }
                  
                })[0];
                $('<input data-type="checkbox" type="checkbox"/>').appendTo(a);
                $('<label>' + heads[i].innerText + '<label>').appendTo(a);
                li.index = i;
    //            li.col = $(el).add(el.headTable).find('col:nth-child(' + (li.index + 1) + ')');
                $(li).find('input[type="checkbox"]').bind('change', function(e) {
                  var target = e.currentTarget;
                  var index = $(target).closest('li')[0].index;
                  if($(target).attr('checked') != undefined) {
                    $.alopexWidget.table.showColumn.apply(el, [index]);
                  } else {
                    $.alopexWidget.table.hideColumn.apply(el, [index]);
                  }
                });
              }
            }
            $.alopex.convert(el.toggleDialog);
            $(btn).bind('tap', function(e) {
              $(el.toggleDialog).find('input[type="checkbox"]').attr('checked', 'checked');
              var cols = $(el).find('col');
              var heads = $(el).find('td, th');
              var checkboxIndex = 0;
              for(var i=0; i<cols.length; i++, checkboxIndex++) {
                if($(heads[i]).attr('data-priority') == undefined) {
                  checkboxIndex--;
                  continue;
                }
                if($(cols[i]).hasClass('af-hidden')) {
                  $($(el.toggleDialog).find('input[type="checkbox"]')[checkboxIndex]).removeAttr('checked');
                }
              }
              if(coordinate != undefined) {
                $(el.toggleDialog).open('', coordinate[1], coordinate[0]);
              } else {
                $(el.toggleDialog).open();
              }
              
              e.stopPropagation();
              $(document).bind('tap', function(e) {
                var target = e.target;
                if($(target).closest('.af-table-dialog').length == 0) {
                  $(el.toggleDialog).close();
                  $(document).unbind('tap');
                }
              });
            });
          },
    
          clear: function(e) {
            var el = this;
            el.body = $(el.rows).splice(1, (el.rows.length-1));
            $(el.body).remove();
          },
    
          _addTableHighlight: function(e) {
            var cell = e.target;
            cell = $(cell).closest('tr,td, th')[0];
            var row = $(cell).closest('tr')[0];
            var head = $(cell).closest('th')[0];
            var table = $(cell).closest('table')[0];
            
            var isHeader = false;
            if (head != undefined) {
              isHeader = true;
            }
    
            $(table).find('.af-table-row').removeClass('af-table-row');
            $(table).find('.af-table-cell').removeClass('af-table-cell');
            $(table).find('.af-table-column').removeClass('af-table-column');
    
            if (isHeader) {
              var index = $.alopexWidget.table.getColumnIndex(cell);
              $(table).find('td:nth-child(' + (index + 1) + '),' + 'th:nth-child(' + (index + 1) + ')')
                .addClass('af-table-column');
            } else {
              $(row).addClass('af-table-row');
              $(cell).addClass('af-table-cell');
            }
          },
    
          /**
           * table 헤더 리턴.
           *  1. <thead>태그가 존재할 경우, thead리턴. 
           *  2. <thead> 없을 시, <th>태그의 부모<tr> 리턴.
           *  3. null 리턴. 
           * 
           * @param el
           * @returns
           */
          getTableHead: function(el) {
            var thead = null;
            if ($(el).find('thead').length > 0) {
              thead = $(el).find('thead')[0];
            } else if ($(el).find('th').length > 0) {
              thead = $(el).find('th')[0].parentNode;
            }
            return thead;
          },
    
          getTableBody: function(el) {
            var tbody;
            if ($(el).find('tbody').length > 0) {
              tbody = el.tBody ? el.tBody : $(el).find('tbody')[0];
            } else {
              tbody = el;
            }
            return tbody;
          },
    
          getRowIndex: function(td) {
            var tr = td.parentNode;
            var table = tr;
            while (table.tagName.toLowerCase() != 'table') {
              table = table.parentNode;
            }
            var tbody = table.tableBody;
            var cnt = 0;
            for (var i = 0; i < tbody.rows.length; i++) {
              if (tbody.rows[i] == table.tableHead) {
                continue;
              } else if (tbody.rows[i] == tr) {
                return cnt;
              }
              cnt++;
            }
            return cnt;
          },
    
          getColumnIndex: function(td) {
            var tr = td.parentNode;
            if ($.alopexUtil.isValid(tr.cells)) {
              for (var i = 0; tr.cells.length; i++) {
                if (tr.cells[i] == td) {
                  return i;
                }
              }
            }
            return -1;
          },
    
          resizeThreshold: 10,
    
          _enableEditing: function(el) {
            $(el.wrapper).delegate("[data-editable='true']", 'tap', $.alopexWidget.table._editHandler);
          },
    
          _disableEdit: function(el) {
            try {
              var thead = el.tableHead;
              var tbody = el.tableBody;
    
              $(thead).find("[data-editable='true']").each(
                  function() {
                    var th = this;
                    var columnIndex = $.alopexWidget.table.getColumnIndex(th);
    
                    for (var i = 0; i < tbody.rows.length; i++) {
                      if (tbody.rows[i] == thead) {
                        continue;
                      }
                      $(tbody.rows[i]).find(
                          'td:nth-child(' + (columnIndex + 1) + ')').unbind(
                          'tap', $.alopexWidget.table._editHandler);
                    }
                  });
            } catch (e) {
              throw new Error(e);
            }
          },
    
          _editHandler: function(e) {
            var cell = $(e.target).closest('td')[0];
            var table = $(cell).closest('table')[0];
    
            // td 안에 textnode 말고 다른
            if (cell.children != undefined && cell.children.length > 0) {
              return;
            }
    
            var input = document.createElement('input');
            $(input).val(cell.text = $(cell).text());
            $.alopexWidget.table.tmpInput = input;
            $.alopexWidget.table.tmp = cell;
            $(cell).text('').append(input).addClass('af-editing');;
            
    
            var temp = cell.style.height;
            $(input).focus();
            $.alopexWidget.table._disableEdit(table);
    
            function focusout(e) {
              e.stopImmediatePropagation();
              e.preventDefault();
    
              var input = $.alopexWidget.table.tmpInput;
              var text = $(input).val();
              if(input.parentNode.text != text) {
                $(input.parentNode).addClass('af-edited');
                table.edited = true;
              }
              $(input.parentNode).text(text)
                .removeClass('af-editing');
              $(input).remove();
              $.alopexWidget.table._enableEditing(table);
            };
    
            $(input).bind('focusout', function(e) {focusout(e);});
            $(input).bind('keydown', function(e) {
                if(e.keyCode != 13 && e.keyCode != 27) {
                  return;
                }
                focusout(e);
            });
          },
    
          _addColgroup: function(el) {
            // colgroup
            var rowgroups = $(el).find('tr');
            rowgroups = rowgroups[rowgroups.length - 1];
            var colgroup = $(el).find('colgroup');
            if (colgroup.length == 0) {
              colgroup = document.createElement('colgroup');
              for (var i = 0; i < rowgroups.children.length; i++) {
                var temp = document.createElement('col');
                $(temp).appendTo(colgroup);
              }
              $(colgroup).insertBefore(el.children[0]);
            } else {
              colgroup = colgroup[0];
            }
          },
          
          _refreshColgroup: function(el) {
            var rowgroups = $(el).find('tr');
            rowgroups = rowgroups[rowgroups.length - 1];
            var colgroup = $(el).find('colgroup');
            var widths = [];
            for (var i = 0; i < rowgroups.children.length; i++) {
              widths.push(rowgroups.children[i].offsetWidth);
            }
            for (var i = 0; i < rowgroups.children.length; i++) {
              $(el).find('col:nth-child(' + (i + 1) + ')').css('width', widths[i]);
            }
            el.colgroup = colgroup;
          },
    
          _enableResizing: function(el) {
            if(window.browser != 'mobile') { // Desktop Only Function
              // register event handler
              $(el.wrapper)
                .delegate("[data-resizable='true']", 'mousedown', $.alopexWidget.table._resizeStartHandler)
                .delegate("[data-resizable='true']", 'mousemove', $.alopexWidget.table._checkResizeCondition);
              $(el.wrapper).find("[data-resizable='true']").each(function() {
                  this.table = el;
                  var btn = document.createElement('div');
                  $(btn).addClass('af-table-resize').appendTo(this);
                });
              $(el.rows[0].cells).each(function(index) {
                this.index = index;
              });
              $(el).on('selectstart', function(e){return false;});
              $(el).on('dragstart', function(e){return false;});
            }
            
          },
    
          _resizeStartHandler: function(e) {
            
            var target = e.currentTarget;
    //        console.log('_resizeStartHandler', target);
            var table = target.table;
            var tableWidth = table.offsetWidth;
            $(table).css('width', tableWidth + 'px');
            if ($.alopexWidget.table.resizeready) {
              $.alopexWidget.table.resizing = true;
              $.alopexWidget.table.resizingEl = target;
              
              $(document).bind('mousemove', $.alopexWidget.table._resizeMoveHandler);
              $(document).bind('mouseup', $.alopexWidget.table._resizeEndHandler);
    //          $(target).unbind('mousemove', $.alopexWidget.table._checkResizeCondition);
              if ($.alopexUtil.isValid($('body').css('cursor'))) {
                $('body').data('cursor', $('body').css('cursor'));
              }
              $('body').css('cursor', 'col-resize').css('text-overflow', 'ellipsis');
            }
          },
          
          _resizeMoveHandler: function(e) {
            if ($.alopexWidget.table.resizing) {
              var col = $.alopexWidget.table.resizingEl;
              var pos = $.alopexUtil.getScrolledPosition(col);
              var left = pos[1];
    //          var right = left + col.offsetWidth;
              
              if(e.pageX > left + 10) {
                var width = e.pageX - left;
                $.alopexWidget.table._resizeColumn(col, width);
              }
            }
          },
          
          _resizeEndHandler: function(e) {
            if ($.alopexWidget.table.resizing) {
              var target = $.alopexWidget.table.resizingEl;
    //          $(target).bind('mousemove', $.alopexWidget.table._checkResizeCondition);
            
              $.alopexWidget.table.resizing = false;
              $.alopexWidget.table.resizingEl = null;
              $(document).unbind('mousemove', $.alopexWidget.table._resizeMoveHandler);
              $(document).unbind('mouseup', $.alopexWidget.table._resizeEndHandler);
              
              if ($.alopexUtil.isValid($('body').data('cursor'))) {
                $('body').css('cursor', $('body').data('cursor'));
              } else {
                $('body').css('cursor', '').css('background', '');
              }
            }
          },
          
          _checkResizeCondition: function(e) {
            var el = $(e.target).closest('[data-resizable="true"]')[0];
            var pos = $.alopexUtil.getScrolledPosition(el);
            var curright = pos[1] + el.offsetWidth;
            if ($(el).css('cursor') != 'col-resize') {
              $(el).data('cursor', '');
            }
            if (e.pageX >= curright - $.alopexWidget.table.resizeThreshold) {
              $(el).css('cursor', 'col-resize');
              $.alopexWidget.table.resizeready = true;
            } else {
              $(el).css('cursor', $(el).data('cursor'));
              $.alopexWidget.table.resizeready = false;
            }
          },
    
          /**
           * @param {HTMLCellElement} el target header td element.
           * @param {integer} width width of td element;
           */
          _resizeColumn: function(el, width) {
            var table = el.table;
            var $table = $(table);
            var head = table.head;
            $(el).css('width', width+'px');
            $($table).find('colgroup > col:nth-child(' + (el.index + 1) + ')').each(function() {
                var colWidth = $($table).find('tr:first-child').find('td,th')[el.index].offsetWidth; 
                var oldColWidth = this.width? this.width : colWidth;
                var oldTableWidth = this.tableWidth? this.tableWidth : parseInt($table.css('width').replace('px', ''));
                var diff = width - oldColWidth;
                this.width = width;
                this.style.width = width+'px'; // for ie7
                $(this).css('width', width + 'px'); // for ie8, ie9
                this.tableWidth = (oldTableWidth + diff);
                $table.css('width', this.tableWidth + 'px');
                $(head).css('width', this.tableWidth + 'px');
            }); 
          },
    
          // "af-table-ascending af-table-descending"
          _enableSorting: function(el) {
            var rows = el.head;
            $(rows).find('th, td').each(function(index){
              if($(this).attr('data-sortable') == undefined && $(this).attr('data-sort-function') == undefined) {
                return ;
              }
              this.columnIndex = index;
              this.table = el;
              var icon = document.createElement('span');
              $(icon).addClass('af-icon');
              $(this).append(icon).css('cursor', 'pointer');
    //          $(this).attr('tabindex', '0');
              
            });
            $(el.wrapper).delegate('[data-sortable], [data-sort-function]', 'tap', $.alopexWidget.table._sort);
          },
    
          _sort: function(e) {
            try {
              var target = e.currentTarget;
              var table = target.table;
              var index = target.columnIndex;
              var tbody = table.tBodies[0];
              
              var array = [];
              var valArr = [];
              for (var i = 0; i < tbody.rows.length; i++) {
                if (tbody.rows[i].cells.length > 0 && tbody.rows[i].cells[0].tagName.toLowerCase() == "th") {
                  continue;
                }
                array.push([$.alopexWidget.table._getInnerText(tbody.rows[i].cells[index]), tbody.rows[i]]);
              }

              
              var sort_function;
              if($(target).attr('data-sort-function') != undefined) {
                sort_function = window[$(target).attr('data-sort-function')];
              } else {
                var type = $(target).attr('data-sortable');
                switch (type) {
                case 'number':
                  sort_function = $.alopexUtil.sort_numeric;
                  break;
                case 'date':
                  valArr = $.alopexUtil.formatDate(valArr);
                  sort_function = $.alopexUtil.sort_date;
                  break;
                default:
                  sort_function = undefined;
                  break;
                }
              }
              
              $(target).siblings().removeClass('af-table-ascending').removeClass('af-table-descending');
              if (target.className.indexOf('af-table-ascending') !== -1) {
                $(target).removeClass('af-table-ascending');
                $(target).addClass('af-table-descending');
                $.alopexWidget.table._setSortTitle(target);
                array.alopexsort(sort_function, false);
              }else {
                $(target).removeClass('af-table-descending');
                $(target).addClass('af-table-ascending');
                $.alopexWidget.table._setSortTitle(target);
                array.alopexsort(sort_function, true);
              }
              
              for (var i = 0; i < array.length; i++) {
                tbody.appendChild(array[i][1]);
              }

              delete array;

            } catch (e) {
              throw new Error('[table _sort] ' + e.message + '\n' + e.fileNmae + '\n' + e.lineNumber);
            }

          },
          
          //오름차순, 내림 차순 시 button에 title 속성 설정
          _setSortTitle: function(target) {
            $(target).siblings().find("button").attr('title', '정렬버튼');
            if (target.className.indexOf('af-table-ascending') != -1) {
              $(target).find("button").attr('title', '오름차순 정렬');
            } else if(target.className.indexOf('af-table-descending') != -1) {
              $(target).find("button").attr('title', '내림차순 정렬');
            } else {
              $(target).find("button").attr('title', '내림차순 정렬');
            }
            
          },
    
          _getInnerText: function(node) {
            // 현재 alopex UI Framework componenet value를 가져와야 함.
            // node가 정의되지 않앗거나, 복합 구조일 경우 빈 스트링 리턴.
            if (!node) {
              return '';
            }
    
            return node.innerHTML;
          }
      },

    /*slider: {
      slider: function(e) {
        var el = this;
        var isTouch = false;

        $.alopexWidget.object.addDefaultStyleClass(el, 'af-slider');

        var sliderbtn = document.createElement('div');
        sliderbtn.minValue = 0;
        sliderbtn.maxValue = 100;
        sliderbtn.value = 0;
        $(sliderbtn).attr('style', 'position:absolute;');
        el.appendChild(sliderbtn);

        sliderbtn.minLeft = el.offsetLeft;
        sliderbtn.maxLeft = el.offsetLeft + el.offsetWidth;
        $(sliderbtn).css('left',
            sliderbtn.minLeft - (sliderbtn.offsetWidth / 2) + 'px');

        var maxWidth = $(el).css('width');
        if ($.alopexUtil.isValid(maxWidth)) {
          sliderbtn.maxWidth = maxWidth.split('px')[0];
        }

        // 버튼 동작 이벤트 컨트롤
        $(sliderbtn).bind('mousedown', function() {
          isTouch = true;
        });

        $(el).bind('mousemove', function(e) {
          if (isTouch) {
            $.alopexWidget.slider._slide(e);
          }
        });

        $(el).bind('mouseup mouseleave', function(e) {
          isTouch = false;
          e.preventDefault();
        });

      },

      _slide: function(e) {
        var el = e.currentTarget;
        var sliderbtn = el.children[0];

        var x = e.pageX;
        //var y = e.pageY;
        //console.log(x,y);

        if (x < sliderbtn.minLeft) {
          x = sliderbtn.minLeft;
          sliderbtn.value = 0;
        } else if (x > sliderbtn.maxLeft) {
          x = sliderbtn.maxLeft;
          sliderbtn.value = 100;
        } else {
          sliderbtn.value = parseInt((x - sliderbtn.minLeft) * 100 /
              (sliderbtn.maxLeft - sliderbtn.minLeft));
        }

        $(sliderbtn).css('left', (x - (sliderbtn.offsetWidth / 2)) + 'px');
        //$(sliderbtn).css('top', y + 'px');
      },

      getValue: function(e) {
        var el = this;
        var sliderbtn = el.children[0];

        return sliderbtn.value;
      }

    },*/

    progressbar: {
      progressbar: function() {
        var el = this;

        $.alopexWidget.object.addDefaultStyleClass(el, 'af-progressbar');

        var progElement = document.createElement('div');
        progElement.minValue = 0;
        progElement.maxValue = 100;
        progElement.value = 0;
        $(progElement).attr('style', 'position:absolute;');
        el.appendChild(progElement);

        $(progElement).css('height', $(el).css('height'));
        progElement.maxWidth = $(el).css('width').split('px')[0];

        var progressImage = $(el).attr('data-image');
        if ($.alopexUtil.isValid(progressImage)) {
          $(progElement).css('background-image', 'url(' + progressImage + ')');
        }

      },

      setProgress: function(value) {
        var el = this;
        var progElement = el.children[0];

        progElement.value = value;
        $(progElement).css('border', $(el).css('border'));
        $(progElement).css('width',
            (progElement.maxWidth * (value / progElement.maxValue)) + 'px');
      },

      getValue: function() {
        var el = this;
        var progElement = el.children[0];

        var value = progElement.value;
        if (value > progElement.maxValue) {
          value = progElement.maxValue;
        } else if (value < progElement.minValue) {
          value = progElement.minValue;
        }
        return value;
      }

    },

    navigationbar: {
      navigationbar: function() {
        var el = this;
        $(el).css('position', 'fixed');
        if ($(el.parentNode).find('[data-type="page"]').length > 0) {
          el.page = $(el.parentNode).find('[data-type="page"]')[0];
          $(el.page).css('transform', 'translateX(0px)');
          $(el.page).css('transition', 'all 0.2s ease-in-out');
        }
      },

      showNaviBar: function() {
        var el = this;
        if ($.alopexUtil.isValid(el.page)) {
          $(el.page).css('transform', 'translateX(240px)');
        }
      },

      dismissNaviBar: function() {
        var el = this;
        if ($.alopexUtil.isValid(el.page)) {
          $(el.page).css('transform', 'translateX(0px)');
        }
      }
    },


    contentslider: {
      contentslider: function() {
        var el = this;
        var that = $.alopexWidget.contentslider;
        var $el = $(el).css('overflow', 'hidden');

        el.pages = $el.find('[data-type="page"]');
        el.position = 0;
        el.height = parseInt($el.css('height'));
        el.width = parseInt($el.css('width'));
        el.maxPosition = -1 * el.width * (el.pages.length - 1);
        el.slidable = document.createElement('div');
        el.appendChild(el.slidable);
        $(el.slidable).css('height', el.height)
          .css('width', el.width * el.pages.length + 'px')
          .css('transform', 'translateX(0px)');

        // page
        if ($.alopexUtil.isValid(el.pages)) {
          el.pages.css('width', $el.css('width'))
            .css('height', $el.css('height'))
            .css('float', 'left').each(function(index) {
              this.index = index;
            });
          for (var i = 0; i < el.pages.length; i++) {
            el.slidable.appendChild(el.pages[i]);
          }
        }

        // event handler binding
        $el.bind('pressed', that._evt_pressed);
        $el.bind('swipemove', that._evt_swipemove);
        $el.bind('swipecancel', that._evt_swipecancel);
        $el.bind('swipe', {distanceX: parseInt($el.css('width')) / 4},
            that._evt_swipe);
      },

      /**
       * attach the slides into the both side of current slide
       * if the number of page equals 2, it will copy unselected page slide.
       */
      _attach: function(el) {
        $(el.slidable).css('transition', 'all 0s ease-in-out');
        if (el.pages.length == 2) { // copy

        } else {
          if (el.position == 0) {
            var targetSlide =
              el.slidable.children[el.slidable.children.length - 1];
            $(el.slidable).prepend($(targetSlide));
            $(el.slidable).css('transform', 'translateX(' +
                (el.position = el.width * -1) + 'px)');
          } else if (el.position == el.maxPosition) {
            var targetSlide = el.slidable.children[0];
            $(el.slidable).append($(targetSlide));
            $(el.slidable).css('transform', 'translateX(' +
                (el.position += el.width) + 'px)');
          }
        }
      },

      /**
       * if the slide was cloned and attach,
       * it will remove the unselected copy.
       */
      _end: function(el) {

      },

      /**
       * the event handler for pressed event
       * it will attach the slides to the both side of current page slide.
       */
      _evt_pressed: function(e, c) {
        var el = e.currentTarget;
        $.alopexWidget.contentslider._attach(el);
      },

      _evt_swipemove: function(e, c) {
        var el = e.currentTarget;
        if (Math.abs(c.distanceX) > el.width) {
          c.distanceX = c.distanceX / c.distanceX * el.width;
        }
        $(el.slidable).css('transform', 'translateX(' +
            (el.position + c.distanceX) + 'px)');
      },

      _evt_swipe: function(e, c) {
        var el = e.currentTarget;
        $(el.slidable).css('transition', 'all 0.3s ease-in-out');
        if (c.distanceX < 0) { // 좌측 이동
          $(el.slidable).css('transform', 'translateX(' +
              (el.position -= el.width) + 'px)');
        } else { // 우측 이동
          $(el.slidable).css('transform', 'translateX(' +
              (el.position += el.width) + 'px)');
        }
      },

      _evt_swipecancel: function(e, c) {
        var el = e.currentTarget;
        $(el.slidable).css('transition', 'all 0.3s ease-in-out');
        $(el.slidable).css('transform', 'translateX(' +
            (el.position) + 'px)');
      },

      nextSlide: function(duration) {
        var el = this;
        $.alopexWidget.contentslider._attach(el);
        setTimeout(function() {
          $(el.slidable).css('transition', 'all 0.3s ease-in-out');
          $(el.slidable).css('transform', 'translateX(' +
              (el.position -= el.width) + 'px)');
        }, 100);
      },

      prevSlide: function(duration) {
        var el = this;
        $.alopexWidget.contentslider._attach(el);
        setTimeout(function() {
          $(el.slidable).css('transition', 'all 0.3s ease-in-out');
          $(el.slidable).css('transform', 'translateX(' +
              (el.position += el.width) + 'px)');
        }, 100);
      }
    },


    /**
     * pageindicator 삭제 예정.
     */
    paging: {
      paging: function() {
        var el = this;
        el.pages = null;
        el.nextbutton = null;
        el.selectedPage = null;
        el.pagingType = null;
        el.maxpage = 10;
        el.totalpage = 10;
        el.startpage = 1;
        el.endpage = 10;

        var $el = $(el);
        var $obj = $.alopexWidget.object;
        $obj.addDefaultStyleClass(el, 'af-paging');

        $el.bind('selectstart', function(e) {
          return false;
        });

        // 이동 버튼 관련 코드.
        var buttons = $el.find('a[data-dest]');
        var handler = null;
        for (var i = 0; i < buttons.length; i++) {
          var dest = $(buttons[i]).attr('data-dest');
          buttons[i].element = el;
          switch (dest) {
          case 'previous':
          case 'prev':
            $obj.addDefaultStyleClass(buttons[i], 'af-paging-prev');
            handler = function(e) {
              var el = e.currentTarget.element;
              if (el.selectedPage != 1) {
                $.alopexWidget.paging.setSelectedPage.apply(el,
                    [el.selectedPage - 1]);
              }
            };
            break;
          case 'previouspages':
          case 'prev-group':
            $obj.addDefaultStyleClass(buttons[i], 'af-paging-prevgroup');
            handler = function(e) {
              var el = e.currentTarget.element;
              if (el.startpage != 1) {
                $.alopexWidget.paging.setSelectedPage.apply(el,
                    [el.startpage - el.maxpage]);
              } else { // if there is no previous page group, select
                $.alopexWidget.paging.setSelectedPage.apply(el, [1]);
              }
            };
            break;
          case 'next':
            if (!el.nextbutton) {el.nextbutton = buttons[i];}
            $obj.addDefaultStyleClass(buttons[i], 'af-paging-next');
            handler = function(e) {
              var el = e.currentTarget.element;
              if (el.selectedPage != el.totalpage) {
                $.alopexWidget.paging.setSelectedPage.apply(el,
                    [el.selectedPage + 1]);
              }
            };
            break;
          case 'nextpages':
          case 'next-group':
            if (!el.nextbutton) {el.nextbutton = buttons[i];}
            $obj.addDefaultStyleClass(buttons[i], 'af-paging-nextgroup');
            handler = function(e) {
              var el = e.currentTarget.element;
              if (el.endpage != el.totalpage) {
                $.alopexWidget.paging.setSelectedPage.apply(el,
                    [el.startpage + el.maxpage]);
              } else {
                $.alopexWidget.paging.setSelectedPage.apply(el, [el.totalpage]);
              }
            };
            break;
          }
          $(buttons[i]).attr('data-type', 'button').button().bind('tap', handler);
        }

        var maxpage = parseInt($el.attr('data-maxpage')) | 0;
        el.maxpage = maxpage;
        $(el).attr('data-maxpage', maxpage);
        
        var totalpage = ($el.attr('data-totalpage')) ?
            parseInt($el.attr('data-totalpage')) : 0;
        el.totalpage = totalpage;
        $(el).attr('data-totalpage', totalpage);
        
        // data-generatelink : 이 플래그 있을 시 page 링크 자동 추가.
        el.pagingType = $el.attr('data-generatelink');
        $.alopexWidget.paging.generateLink(el);
        
        var selectedPgae = ($el.attr('data-selected') != undefined)?
            $el.attr('data-selected') : 1;
        $.alopexWidget.paging.setSelectedPage.apply(el, [selectedPgae, true]);
      },
      
      removeLink: function(el) {
        for (var i = 0; i < el.pages.length; i++) {
          if(el.tagName.toLowerCase() == "ul") { // NH custom
            $(el.pages).parents('li').remove();
          } else {
            $(el.pages).remove();
          }
        }
        
      },
      
      generateLink: function (el) {
        if($(el).find('a:not([data-dest])').length == 0) {
          for (var i = 0; i < el.maxpage; i++) {
            var alink = document.createElement('a');
            $(alink).attr('href', '#none');
            if (el.pagingType != 'mobile') {
              alink.innerHTML = i + 1 + '';
            }
            
            if(el.tagName.toLowerCase() == "ul") { // NH custom
              var li = document.createElement("li");
              $(alink).appendTo(li);
              $(li).css('display', 'none');
              if (el.nextbutton) {
                $(li).insertBefore($(el.nextbutton).parents("li"));
              } else {
                $(li).appendTo(el);
              }
            } else {
              $(alink).css('display', 'none');
              if (el.nextbutton) {
                $(alink).insertBefore(el.nextbutton);
              } else {
                $(alink).appendTo(el);
              }
            }
          }
        }
        
        
        el.pages = $(el).find('a:not([data-dest])');
        for (var i = 0; i < el.pages.length; i++) {
          el.pages[i].page = i + 1;
          el.pages[i].index = i;
          el.pages[i].container = el;
          if (el.pagingType == 'mobile') {
            $.alopexWidget.object.addDefaultStyleClass(el.pages[i], 'af-paging-mobile');
          } else {
            $.alopexWidget.object.addDefaultStyleClass(el.pages[i], 'af-paging-number');
          }
          $(el.pages[i]).bind('tap',
              function(e) {
                var alink = e.currentTarget;
                $.alopexWidget.paging.setSelectedPage.apply(
                    alink.container, [alink.page]);
              });
        }
      },

      /**
       * 페이지 indicator 내에 페이지 정보 수정.
       * @param {integer} page 페이지 그룹 내에 들어갈 특정 페이지.
       */
      changePageGroup: function(el, page) {
        el.startpage = 1;
        el.endpage = el.maxpage;
        while (page > el.endpage) {
          el.startpage += el.maxpage;
          el.endpage += el.maxpage;
        }
        if (el.endpage > el.totalpage) {
          el.endpage = el.totalpage;
        }
        for (var i = 0; i < el.pages.length; i++) {
          if (el.startpage + i <= el.totalpage) {
            if(el.tagName.toLowerCase() == 'ul') { // NH custom
              $(el.pages[i]).parents('li').css('display', '');
            } else {
              $(el.pages[i]).css('display', '');
            }
            
            
            el.pages[i].page = el.startpage + i;
            if (el.pagingType != 'mobile') {
              el.pages[i].innerHTML = el.startpage + i;
            }
          } else {
            if(el.tagName.toLowerCase() == 'ul') { // NH custom
              $(el.pages[i]).parents('li').css('display', 'none');
            } else {
              $(el.pages[i]).css('display', 'none');
            }
            el.pages[i].page = NaN;
          }
        }
      },

      setSelectedPage: function(page, preventTrigger) {
        var el = this;
        page = parseInt(page);
        $.alopexWidget.paging.changePageGroup(el, page);

        var strong = $(el).find('strong');
        if(strong.length != 0) {
          $(strong[0]).replaceWith(strong[0].children);
        }
        for (var i = 0; i < el.pages.length; i++) {
          el.pages[i].className =
            el.pages[i].className.replace('af-paging-selected', '');
            $(el.pages[i]).removeAttr('title');
          if (el.startpage + i == page) {
            el.pages[i].className += ' af-paging-selected';
            $(el.pages[i]).wrap('<strong></strong>');
            $(el.pages[i]).attr('title', '현재페이지');
          }
        }
        el.selectedPage = page;
        
        $.alopexWidget.paging._enableAllButton(el);
        if(el.selectedPage == 1) { // disable prev button
          $.alopexWidget.paging._disableButton(el, 'prev');
        }
        if(el.startpage == 1) { // disable prev group button
          $.alopexWidget.paging._disableButton(el, 'prev-group');
        } 
        if(el.selectedPage == el.totalpage) { // disable next button
          $.alopexWidget.paging._disableButton(el, 'next');
        } 
        if(el.endpage == el.totalpage) { // disable next group button
          $.alopexWidget.paging._disableButton(el, 'next-group');
        }
        
        if(preventTrigger == undefined) {
          $(el).trigger('pagechange', [page]);
        }
        
        
      },
      
      _enableAllButton : function(el) {
        $(el).find('[data-dest]').setEnabled(true);
        $(el).find('[data-dest]').css('visibility', 'visible');
      },
      
      _disableButton: function(el, btnType) {
        var $button = $(el).find('[data-dest="' + btnType + '"]');
        if($(el).attr('data-button-behavior') == 'disable') {
          $button.setEnabled(false);
        } else {
          $button.css('visibility', 'hidden');
        }
      },

      getSelectedPage: function() {
        var el = this;
        return el.selectedPage;
      },

      setTotalPage: function(page, destpage) {
        var el = this;
        page = parseInt(page);
        el.totalpage = page;
        $(el).attr('data-totalpage', page);
        $.alopexWidget.paging.changePageGroup(el, el.selectedPage);
        if($.alopexUtil.isValid(destpage)) {
          $.alopexWidget.paging.setSelectedPage.apply(el, [destpage]);
        }
      },
      
      setMaxPage: function(page, destpage) {
        var el = this;
        page = parseInt(page);
        el.maxpage = page;
        $(el).attr('data-maxpage', page);
        $.alopexWidget.paging.removeLink(el);
        $.alopexWidget.paging.generateLink(el);
        $.alopexWidget.paging.changePageGroup(el, el.selectedPage);
        if($.alopexUtil.isValid(destpage)) {
          $.alopexWidget.paging.setSelectedPage.apply(el, [destpage]);
        } else {
          $.alopexWidget.paging.setSelectedPage.apply(el, [el.selectedPage]);
        }
        
      }
    },

    /**
     * 추후 메뉴와 accordion 두개 component로 분리 필요.
     * expand & collapse 함수 추가 예정.
     */
    navmenu: {
      navmenu: function() {
        var el = this;
        $.alopexWidget.object.addDefaultStyleClass(el, 'af-navmenu');
        $(el).children('ul').addClass('af-navmenu-main')
          .find('ul').addClass('af-navmenu-sub').css('display', 'none');
        $(el).find('li').each(function() {
          var li = this;
          for (var i=0; i<li.children.length; i++) {
            if (li.children[i].tagName.toLowerCase() == 'ul') {
              $(li).addClass('af-expandable');
              $(li).append($(document.createElement('span')).addClass('af-icon')[0]);
              break;
            }
          }
        });
        $(el).bind('dragstart selectstart', function(e) {
          return false;
        });
        $.alopexWidget.navmenu.resizeHandler();
        $(window).bind('resize', $.alopexWidget.navmenu.resizeHandler);
      },
      
      setDataSource: function(jsonArray) {
        var el = this;
        $(el).empty();
        var ul = $('<ul></ul>').appendTo(el)[0];
        $.alopexWidget.navmenu._createNode(ul, jsonArray);
        el.converted = false;
        $(el).navmenu();
      },
      
      _createNode: function(ul, jsonArray) {
        for(var i=0; i<jsonArray.length; i++) {
          var item = jsonArray[i];
          var li = $('<li></li>').appendTo(ul)[0];
          if($.alopexUtil.isValid(item.id)) {
            $(li).attr('data-id', item.id);
          }
          var a = $('<a></a>').appendTo(li)[0];
          if($.alopexUtil.isValid(item.linkUrl)) {
            $(a).attr('href', item.linkUrl);
          }
          if($.alopexUtil.isValid(item.iconUrl)) {
            $('<img/>').attr('src', item.iconUrl).appendTo(a);
          }
          $('<span></span>').html(item.text).appendTo(a);
          
          if($.alopexUtil.isValid(item.items)) {
            var subul = $('<ul></ul>').appendTo(li)[0];
            $.alopexWidget.navmenu._createNode(subul, item.items);
          }
        }
      },
      
      resizeHandler: function() {
        var menus = $('nav[data-type="navmenu"]');
        var clientWidth = document.documentElement.clientWidth;
        if(clientWidth <= $.alopex.responsive.threshold) { // mobile
          menus.removeClass('af-desktop').addClass('af-mobile')
          .each(function() {
            $.alopexWidget.navmenu.removeMobileEvent(this);
            $.alopexWidget.navmenu.removeDesktopEvent(this);
            $.alopexWidget.navmenu.addMobileEvent(this);
          });
          
        } else {
          menus.addClass('af-desktop').removeClass('af-mobile')
          .each(function() {
            $.alopexWidget.navmenu.removeMobileEvent(this);
            $.alopexWidget.navmenu.removeDesktopEvent(this);
            $.alopexWidget.navmenu.addDesktopEvent(this);
          });
        }
        menus.find('[class~=af-navmenu-expand]').removeClass('af-navmenu-expand').find('> ul').css('display', 'none');
      },
      
      addDesktopEvent: function(el) {
        var tempEl = el;
        $(el).bind('mouseleave', function(e) { // hoverend to mousemove
          var target = e.target;
          var parentNav = $(target).closest('nav');
          parentNav.find('[class~=af-navmenu-expand]').removeClass('af-navmenu-expand').find('> ul').css('display', 'none');
        });
        $(el).bind('mousemove', function(e) { // hoverend to mousemove
          var target = e.target;
          var parentNav = $(target).closest('nav');
          if( parentNav != undefined && parentNav[0] == tempEl) {
            var li = $(target).closest('li')[0];
            if($(li).attr('class') != undefined && $(li).attr('class').indexOf('af-expandable') != -1) {
              $(li).siblings('[class~=af-navmenu-expand]').removeClass('af-navmenu-expand').find('> ul').css('display', 'none')
              .find('[class~=af-navmenu-expand]').removeClass('af-navmenu-expand').find('> ul').css('display', 'none');
              $(li).addClass('af-navmenu-expand').find('> ul').css('display', 'inline-block').find('[class~=af-navmenu-expand]').removeClass('af-navmenu-expand').find('> ul').css('display', 'none');
            }
            
          } else {
            $(tempEl).find('li').removeClass('af-navmenu-expand').find('> ul').css('display', 'none');;
          }
        });
      },
      
      removeDesktopEvent: function(el) {
        $(el).unbind('mouseleave').unbind('mousemove');
      },
      
      addMobileEvent: function(el) {
        var tempEl = el;
        $(el).find('li').bind('tap', function(e) {
          var target = e.target;
          var parentNav = $(target).closest('nav');
          if( parentNav != undefined && parentNav[0] == tempEl) {
            var li = $(target).closest('li')[0];
            $(li).siblings('[class~=af-navmenu-expand]').removeClass('af-navmenu-expand').find('> ul').css('display', 'none');
            if($(li).attr('class').indexOf('af-navmenu-expand') == -1) {
              $(li).addClass('af-navmenu-expand').find('> ul').css('display', 'inline-block');
            } else {
              $(li).removeClass('af-navmenu-expand').find('> ul').css('display', 'none');
            }
//            $(li).toggleClass('af-navmenu-expand');
          }
          e.stopPropagation();
        });
      },
      
      removeMobileEvent: function(el) {
        $(el).find('li').unbind('tap');
      }
    },


    tree: {
      tree: function(options) {
        var el = this;
        $(el).bind('selectstart', function(e){return false;});
        $.alopexWidget.object.addDefaultStyleClass(el, 'af-tree');
        $.alopexWidget.tree.refresh(el);
      },
      
      toggleExpand: function(node) {
        if(node == undefined) {
          node = this;
        } else {
          node = node.node;
        }
        $.alopexWidget.tree._toggle(node);
      },
      
      _toggle: function(li) {
        if(!$.alopexUtil.parseBoolean($(li).attr('data-expand'))){
          $.alopexWidget.tree._expand(li);
        }else{
          $.alopexWidget.tree._collapse(li);
        }
      },
      
      toggleCheckbox: function() {
        var el = this;
        if($(el).attr('data-checkbox') != 'visible') {
          $(el).attr('data-checkbox', 'visible');
          $(el).find('input[type="checkbox"]').css('display', 'inline-block');
        } else {
          $(el).removeAttr('data-checkbox');
          $(el).find('input[type="checkbox"]').css('display', 'none');
        }
      },
      
      expand: function(node) {
        if(node == undefined) {
          node = this;
        }
        var li = node.node;
        $.alopexWidget.tree._expand(li);
      },
      
      _expand: function(li) {
        
        var el = $(li).closest('nav');
        $(li).attr('data-expand', 'true').addClass('af-tree-expanded');
        $(li).find('> ul').css('display', 'block');
        $(el).trigger('expand');
      },
      
      collapse: function(node) {
        if(node == undefined) {
          node = this;
        }
        var li = node.node;
        $.alopexWidget.tree._collapse(li);
      },
      
      _collapse: function(li) {
        if(li == undefined) {
          li = this;
        }
        var el = $(li).closest('nav');
        $(li).attr('data-expand', 'false').removeClass('af-tree-expanded');
        $(li).find('> ul').css('display', 'none');
        $(el).trigger('collapse');
      },
      
      setSelected: function (node) {
        node = node.node;
        $(node).closest('nav').find('[class~=af-selected]').removeClass('af-selected');
        $(node).find('> a').addClass('af-selected');
      },
      
      expandAll: function() {
        var el = this;
        $(el).find('.af-tree-node').each(function() {
          $.alopexWidget.tree._expand(this);
        });
      },
      
      collapseAll: function() {
        var el = this;
        $(el).find('.af-tree-node').each(function() {
          $.alopexWidget.tree._collapse(this);
        });
      },
      
      createNode: function(node, data){
        if(node == undefined) {
          node = this;
        } else {
          node = node.node;
        }
        var ul = $(node).find('ul');
        if(ul.length > 0) {
          ul = ul[0];
        } else {
          ul = $('<ul></ul>').appendTo(node)[0];
        }
        var jsonArray = [data];
        $.alopexWidget.tree._createNode(ul, jsonArray); // same structure
        
        $.alopexWidget.tree.refresh($(node).closest('nav')[0]);
      },
      
      deleteNode: function(node){
        node = node.node;
        var $checkbox = $(node).find('input[type="checkbox"]');
        $checkbox.removeAttr('checked');
        $.alopexWidget.tree._traverseUp($checkbox[0]);
        $(node).remove();
      },
      
      editNode: function(node, data){
        node = node.node;
        $(node).find('> a > span.af-tree-label').text(data.text);
        $(node).find('> a > img.af-tree-img').attr('src', data.iconUrl);
        $(node).attr('id', data.id);
      },
      
      getNode: function (text, type) {
        var el = this;
        var node;
        if(type == 'id') {
          node = $(el).find('[data-id="' + text + '"]')[0];
        } else {
          $(el).find('span.af-tree-label').each(function () {
            if($(this).text() == text) {
              node = $(this).closest('li')[0];
            }
          });
        }
        return $.alopexWidget.tree._getTreeNodeObj(node);
      },
      
      getSelectedNode: function(el) {
        if(el == undefined) {
          var el = this;
        }
        var node = $(el).find('.af-selected').closest('li')[0];
        return $.alopexWidget.tree._getTreeNodeObj(node);
      },
      
      getCheckedNodes: function(el) {
        if(el == undefined) {
          var el = this;
        }
        var array = [];
        $(el).find('input[type="checkbox"]:checked').each(function() {
          var node = $(el).find('.af-selected').closest('li')[0];
          array.push($.alopexWidget.tree._getTreeNodeObj(node));
        });
        return array;
      },
      
      setDataSource: function(jsonArray) {
        var el = this;
        $(el).empty();
        var ul = $('<ul></ul>').appendTo(el)[0];
        $.alopexWidget.tree._createNode(ul, jsonArray); // same structure
        el.converted = false;
        $(el).refresh();
      },
      
      _getTreeNodeObj: function(node) {
        return { text: $(node).find('> a > span.af-tree-label').text(),
          iconUrl: $(node).find('> a > img.af-tree-img').attr('src'),
          id: $(node).attr('data-id'), 
          node: node
        };
      },
      
      _createNode: function(ul, jsonArray) {
        for(var i=0; i<jsonArray.length; i++) {
          var item = jsonArray[i];
          var li = $('<li></li>').appendTo(ul)[0];
          if($.alopexUtil.isValid(item.id)) {
            $(li).attr('data-id', item.id);
          }
          var a = $('<a></a>').appendTo(li)[0];
          if($.alopexUtil.isValid(item.linkUrl)) {
            $(a).attr('href', item.linkUrl);
          }
          if($.alopexUtil.isValid(item.iconUrl)) {
            $('<img/>').attr('src', item.iconUrl).appendTo(a);
          }
          $('<span></span>').html(item.text).appendTo(a);
          
          if($.alopexUtil.isValid(item.items)) {
            var subul = $('<ul></ul>').appendTo(li)[0];
            $.alopexWidget.tree._createNode(subul, item.items);
          }
        }
      },
      
      refresh: function(el) {
        if(el == undefined) {
          el = this;
        }
        $.alopexWidget.tree._structure(el.children[0]);
        $.alopexWidget.tree._removeEvent(el);
        $.alopexWidget.tree._addBasicEvent(el);
        if($.alopexUtil.parseBoolean($(el).attr('data-keybind'))) {
          $.alopexWidget.tree._addKeydownEvent(el);
        }
        $.alopexWidget.tree._addCheckbox(el);
        $(el).find('.af-tree-node').each(function() {
          if(!$.alopexUtil.parseBoolean($(this).attr('data-expand'))) {
            $.alopexWidget.tree._collapse(this);
          }
        });
      },

      _structure: function(ul) {
        $(ul).find('> li').addClass('af-tree-node').each(function() {
          var $link = $(this).find('> a').addClass('af-tree-link');
          $link.find('> img').addClass('af-tree-img');
          $link.find('> span').addClass('af-tree-label');

          var children = $(this).find('> ul').addClass('class', 'af-tree-group');
          var isExpandable = (children.length > 0);
          if(isExpandable) {
            if($link.siblings('span').length == 0) {
              $('<span></span>').attr('class', 'af-tree-icon').attr('data-expand', 'false')
              .insertBefore($(this).find('> a')[0]);
            }
            $.alopexWidget.tree._structure(children[0]);
          } 
        });
      },
      
      _removeEvent: function(el) {
        $(el).find('.af-tree-icon').unbind('tap');
        $(el).find('.af-tree-link').unbind('tap')
          .unbind('doubletap').unbind('hoverstart');
      },
      
      _triggerEvent: function(el, link, event) {
        var _id= $(link.parentNode).attr('data-id');
        var _text = $.alopexWidget.tree._getNodeText(link); 
        var _path = $.alopexWidget.tree._getNodePath(link);
        
        var param = {
            id: _id,
            text: _text,
            path: _path
        };
        
        $(el).trigger(event, [param]);
      },

      _addBasicEvent: function(el) {
        $(el).find('.af-tree-icon').bind('tap', function(e) {
          var li = e.currentTarget.parentNode;
          $.alopexWidget.tree._toggle(li);
        });
        $(el).find('.af-tree-link').bind('doubletap', function(e) {
          var leaf = e.currentTarget;
          $.alopexWidget.tree._triggerEvent(el, leaf, 'doubleselect');
          $.alopexWidget.tree._triggerEvent(el, leaf, 'dbclick');
        });
        $(el).find('.af-tree-link').bind('tap', function(e) {
          var target = e.currentTarget;
          $(target).closest('nav').find('[class~=af-selected]').removeClass('af-selected');
          $(target).addClass('af-selected');
          $.alopexWidget.tree._triggerEvent(el, target, 'select');
        });
        $(el).find('.af-tree-link').bind('hoverstart', function(e) {
          var target = e.currentTarget;
          $(target).closest('nav').find('[class~=af-hover]').removeClass('af-hover');
          $(target).addClass('af-hover');
          $.alopexWidget.tree._triggerEvent(el, target, 'over');
        });
      },
      
      _getNodeText: function(leaf) {
        return $(leaf).children('span').text();
      },
      
      _getNodePath: function(leaf) {
        path = '/' + $.alopexWidget.tree._getNodeText(leaf);
        try{
          while($(leaf).closest('ul').siblings('a').length > 0) {
            leaf = $(leaf).closest('ul').siblings('a')[0];
            path = '/' + $.alopexWidget.tree._getNodeText(leaf) + path;
          }
          return path;
        } catch(e) {
          return path;
        }
        
      },

      _addKeydownEvent: function(el) {
        $(el).find('.af-tree-link').bind('tap', function(e) {
          $.alopexWidget.tree.currentTree = el;
          $(window).bind('mousedown', function(e) {
            var target = e.target;
            var nav = $(target).closest('nav');
            if(nav.length == 0 || nav[0] != el) {
              $(window).unbind('keydown');
              $(window).unbind('mousedown');
            }
          });
          $(window).unbind('keydown');
          $(window).bind('keydown', function(e) {
            $hovertarget = $($.alopexWidget.tree.currentTree).find('[class~="af-hover"]');
            $selecttarget = $($.alopexWidget.tree.currentTree).find('[class~="af-selected"]');
            if($hovertarget == undefined) {
              $hovertarget = $selecttarget;
            }
            if(e.which == 37) { // Left
              if($hovertarget.parent().attr('data-expand') != 'true') {
                var $parent = $hovertarget.closest('ul').siblings('[class~="af-tree-link"]');
                if($parent.length > 0) {
                  $hovertarget.removeClass('af-hover');
                  $parent.addClass('af-hover');
                }
                
              } else {
                var li = $hovertarget.parent()[0];
                $.alopexWidget.tree._toggle(li);
              }
            } else if(e.which == 38) { // Up
              $nav = $hovertarget.closest('nav');
              $leaves = $nav.find('[class~="af-tree-link"]');
              var pass = false;
              var i=$leaves.length-1;
              for(; i>=0; i--) {
                if(!pass) {
                  if($leaves[i] == $hovertarget[0]) {
                    pass = true;
                  }
                } else {
                  if($($leaves[i]).closest('ul').css('display') != "none") {
                    break;
                  }
                }
              }
              if(i>=0) {
                $leaves.removeClass('af-hover');
                $($leaves[i]).addClass('af-hover');
              }
            } else if(e.which == 39) { // Right
              if($hovertarget.parent().attr('data-expand') != 'true') {
                var li = $hovertarget.parent()[0];
                $.alopexWidget.tree._toggle(li);
              } else {
                if($hovertarget.siblings('ul').find('[class~="af-tree-link"]').length > 0) {
                  $hovertarget.removeClass('af-hover');
                  $($hovertarget.siblings('ul').find('[class~="af-tree-link"]')[0]).addClass('af-hover');
                }
              }
            } else if(e.which == 40) { // Down
              $nav = $hovertarget.closest('nav');
              $leaves = $nav.find('[class~="af-tree-link"]');
              var pass = false;
              var i=0;
              for(; i<$leaves.length; i++) {
                if(!pass) {
                  if($leaves[i] == $hovertarget[0]) {
                    pass = true;
                  }
                } else {
                  if($($leaves[i]).closest('ul').css('display') != "none") {
                    break;
                  }
                }
              }
              if(i<$leaves.length) {
                $leaves.removeClass('af-hover');
                $($leaves[i]).addClass('af-hover');
              }
              
            } else if(e.which == 13) { // Enter
              $selecttarget.removeClass('af-selected');
              $hovertarget.addClass('af-selected');
            } else if(e.which == 27) { // Esc
              $(document).unbind('keydown');
            } else {
              return ;
            }
            e.stopPropagation();
            e.preventDefault();
            
          });
        });
      },
      
      _addCheckbox: function(el) {
        $(el).find('.af-tree-link').each(function () {
          if($(this).siblings('input[type="checkbox"]').length == 0) {
            $checkbox = $('<input type="checkbox"/>').insertBefore(this);
            $checkbox.attr('data-type', 'checkbox')
            .css('display', 'none').checkbox()
            .bind('change', $.alopexWidget.tree._checkboxHandler);
//            .css('margin', '0px');
            $checkbox.attr('style', $checkbox.attr('style') + ";margin:0px !important;");
          }
        });
        if($(el).attr('data-checkbox') == "visible") {
          $(el).find('input[type="checkbox"]').css('display', 'inline-block');
        }
      },
      
      _checkboxHandler: function (e) {
        var checkbox = e.currentTarget;
        if($(checkbox).attr('checked') == 'checked') {
          $(checkbox.parentNode).find('input[type="checkbox"]').attr('checked', 'checked').prop('indeterminate', false);
        } else {
          $(checkbox.parentNode).find('input[type="checkbox"]').removeAttr('checked').prop('indeterminate', false);
        }
        $.alopexWidget.tree._traverseUp(checkbox);
      },
      

      _traverseUp: function(checkbox) {
        var numCheckbox = $(checkbox).closest('ul').find('> li > input').length;
        var numChecked = 0;
        var numIndeterminate = 0;
        $(checkbox).closest('ul').find('> li > input').each(function() {
          if(this.indeterminate) {
            numIndeterminate ++;
          } else if ( $(this).attr('checked') != undefined) {
            numChecked ++;
          }
        });
        var parentCheckbox = $(checkbox).closest('ul').siblings('input[type="checkbox"]');
        if(parentCheckbox.length > 0) {
          if(numChecked == 0 && numIndeterminate == 0) {
            parentCheckbox.removeAttr('checked');
            parentCheckbox.prop('indeterminate', false);
          } else if(numChecked == numCheckbox) {
            parentCheckbox.attr('checked', 'checked');
            parentCheckbox.prop('indeterminate', false);
          } else { // indeterminate
            parentCheckbox.removeAttr('checked');
            parentCheckbox.prop('indeterminate', true);
          }
          $.alopexWidget.tree._traverseUp(parentCheckbox[0]);
        }
      }
    }
  };
  
  

  //-----------------------DatePicker----------------------

  /**
   * 생성된 Datepicker객체들을 보관하며 set, get, remove 메소드 제공.
   */
  $.datePickerMap = {

    datePickerObj: {},

    setObject: function(id, obj) {
      this.datePickerObj[id] = obj;
    },

    getObjectByNode: function(node) {

      var temp = $(node);

      while (temp.attr('data-type') != 'af-datepicker') {
        temp = temp.parent();
      }

      return this.datePickerObj[temp.attr('id')];
    },

    getObjectById: function(id) {

      var objId = '';

      if (id.indexOf('datepicker_') < 0) {
        objId = 'datepicker_' + id;
      } else {
        objId = id;
      }

      return this.datePickerObj[objId];
    },

    removeObjectById: function(id) {

      var objId = '';

      if (id.indexOf('datepicker_') < 0) {
        objId = 'datepicker_' + id;
      } else {
        objId = id;
      }

      delete this.datePickerObj[objId];
    },

    removeObjectByNode: function(node) {

      var temp = $(node);

      while (temp.attr('data-type') != 'af-datepicker') {
        temp = temp.parent();
      }

      delete this.datePickerObj[temp.attr('id')];
    }
  };

  /**
   * DatePicker 구성을 위한 Property 및 method
   */
  $.datePicker = {

    MONTHS_KO: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
    MONTHS_EN: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul',
        'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
    MONTHS_JP: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
    MONTHS_CN: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],

    WEEKDAYS_KO: ['일', '월', '화', '수', '목', '금', '토'],
    WEEKDAYS_EN: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday',
        'Friday', 'Saturday'],
    WEEKDAYS_JP: ['日', '月', '火', '水', '木', '金', '土'],
    WEEKDAYS_CN: ['日', '一', '二', '三', '四', '五', '六'],

    POSTFIX_KO: ['년', '월', '일'],
    POSTFIX_EN: ['', '', ''],
    POSTFIX_JP: ['年', '月', '日'],
    POSTFIX_CN: ['年', '月', '日'],
    
    DESC_PREVYEAR_KO: '이전 년도',
    DESC_PREVYEAR_EN: 'previous year',
    
    DESC_NEXTYEAR_KO: '다음 년도',
    DESC_NEXTYEAR_EN: 'next year',
    
    DESC_PREVMONTH_KO: '이전 월',
    DESC_PREVMONTH_EN: 'previous month',
    
    DESC_NEXTMONTH_KO: '다음 월',
    DESC_NEXTMONTH_EN: 'next month',
    
    DESC_CLOSE_KO: '닫기',
    DESC_CLOSE_EN: 'close',

    currentDate: null, //today info
    weekdays: [],
    months: [],
    dateFormat: null,
    datePostfix: [],
    localeInfo: null,
    certainDates: [],
    minDate : null,
    maxDate : null,
    
    descPrevYear: null,
    descNextYear: null,
    descPrevMonth: null,
    descNextMonth: null,
    descClose: null,

    daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
    calendarBody: null, //'일' 표시 영역(tbody)
    calendarMonth: null, //header의 '월' 라벨 영역
    calendarYear: null, //header의 '연도' 라벨 영역
    prevMonth: null,
    nextMonth: null,
    prevYear: null,
    nextYear: null,
    btn_close: null,
    _renderCache: [],
    targetElem: null, //datePicker의 위치에 기준이 되는 element
    _callback: null,
    calendarContainer: null,
    datePickerTheme: 'af-default',//default 테마 Class명
    currentArea: null,
    isInline : false,

    /**
     * @param {json} param : json형의 option 값.
     */
    setDefaultDate: function(param) {

      try {
        this.currentDate = new Date(); // default : today

        if ($.alopexUtil.isValid(param)) {

          if (param.hasOwnProperty('date')) {

            var obj = param.date;

            if (!$.alopexUtil.isValid(obj.year) ||
                !$.alopexUtil.isNumberType(obj.year) ||
                obj.year < 1900 || obj.year > 2100 ||
                !$.alopexUtil.isValid(obj.month) ||
                !$.alopexUtil.isNumberType(obj.month) ||
                obj.month < 1 || obj.month > 12 ||
                !$.alopexUtil.isValid(obj.day) ||
                !$.alopexUtil.isNumberType(obj.day) ||
                obj.day > 31 || obj.day < 1) {

              throw '[DatePicker Error] Invalid Date => ' + obj.year + '-' +
              obj.month + '-' + obj.day;
            }

            this.currentDate = new Date(obj.year, (obj.month - 1), obj.day);
          }
        }

      } catch (e) {
        console.log(e);
      }
    },

    /**
     * @param {json} param : return 되는 날짜 정보 format의 key, value.
     * ex) {"format" : "yyyy-MM-dd"}.
     */
    setFormat: function(param) {

      var formatStr = 'yyyyMMdd'; //default

      if ($.alopexUtil.isValid(param) && param.hasOwnProperty('format') &&
          $.alopexUtil.isValid(param.format)) {
        var pattern = /[Y|m|D|e]/g;

        if (!pattern.test(param.format)) {
          formatStr = param.format;
        } else {
          console.log('[DatePicker Error] Invalid Date Pattern' +
              '(y, M, d, E only) => ' + param.format);
        }
      }

      this.dateFormat = formatStr;
    },

    /**
     * @param {json} param : 달력에 표시되는 월, 요일 영역의 Locale 정보.
     * ex) {"locale" : "ko | en | jp | cn"}.
     */
    setLocale: function(param) {

      var localeStr = 'ko'; //default
      this.localeInfo = 'ko'; //default

      if ($.alopexUtil.isValid(param)) {
        if (param.hasOwnProperty('locale')) {
          localeStr = param.locale;
        }
      }

      switch (localeStr) {
      case 'en':
        this.weekdays = this.WEEKDAYS_EN;
        this.months = this.MONTHS_EN;
        this.datePostfix = this.POSTFIX_EN;
        this.descPrevYear = this.DESC_PREVYEAR_EN;
        this.descNextYear = this.DESC_NEXTYEAR_EN;
        this.descPrevMonth = this.DESC_PREVMONTH_EN;
        this.descNextMonth = this.DESC_NEXTMONTH_EN;
        this.descClose = this.DESC_CLOSE_EN;
        this.localeInfo = 'en';
        break;

      case 'ko':
        this.weekdays = this.WEEKDAYS_KO;
        this.months = this.MONTHS_KO;
        this.datePostfix = this.POSTFIX_KO;
        this.descPrevYear = this.DESC_PREVYEAR_KO;
        this.descNextYear = this.DESC_NEXTYEAR_KO;
        this.descPrevMonth = this.DESC_PREVMONTH_KO;
        this.descNextMonth = this.DESC_NEXTMONTH_KO;
        this.descClose = this.DESC_CLOSE_KO;
        this.localeInfo = 'ko';
        break;

      case 'jp':
        this.weekdays = this.WEEKDAYS_JP;
        this.months = this.MONTHS_JP;
        this.datePostfix = this.POSTFIX_JP;
        this.descPrevYear = this.DESC_PREVYEAR_EN;
        this.descNextYear = this.DESC_NEXTYEAR_EN;
        this.descPrevMonth = this.DESC_PREVMONTH_EN;
        this.descNextMonth = this.DESC_NEXTMONTH_EN;
        this.descClose = this.DESC_CLOSE_EN;
        this.localeInfo = 'jp';
        break;

      case 'cn':
        this.weekdays = this.WEEKDAYS_CN;
        this.months = this.MONTHS_CN;
        this.datePostfix = this.POSTFIX_CN;
        this.descPrevYear = this.DESC_PREVYEAR_EN;
        this.descNextYear = this.DESC_NEXTYEAR_EN;
        this.descPrevMonth = this.DESC_PREVMONTH_EN;
        this.descNextMonth = this.DESC_NEXTMONTH_EN;
        this.descClose = this.DESC_CLOSE_EN;
        this.localeInfo = 'cn';
        break;

      default:
        this.weekdays = this.WEEKDAYS_KO;
        this.months = this.MONTHS_KO;
        this.datePostfix = this.POSTFIX_KO;
        this.descPrevYear = this.DESC_PREVYEAR_KO;
        this.descNextYear = this.DESC_NEXTYEAR_KO;
        this.descPrevMonth = this.DESC_PREVMONTH_KO;
        this.descNextMonth = this.DESC_NEXTMONTH_KO;
        this.descClose = this.DESC_CLOSE_KO;
        this.localeInfo = 'ko';
      }
    },

    /**
     * 특정 style을 적용하기 위한 날짜들의 정보를 저장.
     * @param {json} param : option값, 'certainDates' key에 날짜정보들이 존재.
     */
    setCertainDates: function(param) {

      if ($.alopexUtil.isValid(param) && param.hasOwnProperty('certainDates')) {
        this.certainDates = param.certainDates;
      }
    },
    
    setThemeClass: function(param) {
      
      if ($.alopexUtil.isValid(param) && param.hasOwnProperty('themeClass')) {
        this.datePickerTheme = param.themeClass;
      }
    },
    
    setInline: function(param) {
      
      if ($.alopexUtil.isValid(param) && param.hasOwnProperty('inline')) {
        this.isInline = param.inline;
      }
    },
    
    setMinDate: function(param) {
      
      if ($.alopexUtil.isValid(param) && param.hasOwnProperty('minDate')) {
        this.minDate = param.minDate;
      }else{
        this.minDate = new Date('1900/1/1');
      }
      
      if(this.currentDate < this.minDate){
        this.currentDate = this.minDate;
      }
    },
    
    setMaxDate: function(param) {
      
      if ($.alopexUtil.isValid(param) && param.hasOwnProperty('maxDate')) {
        this.maxDate = param.maxDate;
      }else{
        this.maxDate = new Date('2100/12/31');
      }
      
      if(this.maxDate < this.currentDate){
        this.currentDate = this.maxDate;
      }
      
      //minDate가 maxDate 보다 클 경우 둘 다 default로 초기화
      if(this.maxDate < this.minDate){
        this.minDate = new Date('1900/1/1');
        this.maxDate = new Date('2100/12/31');
      }
      
    },

    /**
     * 전달받은 날짜가 특정 날짜의 정보에 저장된 날짜인지 확인. true이면
     * 전달받은 type에 따라 해당 값을 return, 저장된 날짜가 아니면 false return.
     *
     * @param {number} day : 특정 날짜 정보를 조회 할 날짜일수.
     * @param {string} type : true일 경우 return할 key 값('name' | 'styleClass').
     * @return {date | boolean false} 저장된 날짜가 아니면 false return.
     */
    _isCertainDate: function(day) {
        for (var i = 0; i < this.certainDates.length; i++) {
            var certainDateInfo = this.certainDates[i];

            for (var j = 0; j < certainDateInfo.dates.length; j++) {
              if (this.currentYearView == certainDateInfo.dates[j].getFullYear()
                 && this.currentMonthView == certainDateInfo.dates[j].getMonth()
                 && day == certainDateInfo.dates[j].getDate()) {

                return certainDateInfo;
              }
            }
        }

        return false;
    },
    
    _isBelowMinDate: function(day) {
      
      var currentDate = new Date(this.currentYearView, this.currentMonthView, day);
      
      if(currentDate < this.minDate){
        return true;
      }else{
        return false;
      }
    },
    
    _isAboveMaxDate: function(day) {
      
      var currentDate = new Date(this.currentYearView, this.currentMonthView, day);
      
      if(this.maxDate < currentDate){
        return true;
      }else{
        return false;
      }
    },

    /**
     * formatStr에 따라 날짜 정보를 적용 한 후 지정된 callback 함수에 return.
     * @param {json} dateObj : 날짜정보 (year, month, day).
     * @param {string} formatStr : 날짜 format 문자열.
     * @param {string} certainDatesName :
     *  특정 날짜정보들의 집합 중 선택된 정보의 'name' key의 value.
     */
    getDateByFormat: function(dateObj, formatStr, certainDatesName) {

      var dateStr = '';

      //return 할 (json)date. value는 string 형 임.
      var date = {
        year: dateObj.year + '',
        month: dateObj.month + '',
        day: dateObj.day + ''
      };

      var param_date = new Date(dateObj.year, (dateObj.month - 1), dateObj.day);

      var i = 0;
      var num_y = 0; // the number of 'y'
      var num_M = 0; // the number of 'M'
      var num_d = 0; // the number of 'd'
      var num_E = 0; // the number of 'E'
      var delegator = []; // 구분자 보관
      var value_type = []; // 입력한 Format 순서에 맞게 날짜 타입 보관(년, 월, 일, 요일)
      var resultData = []; // delegator와 join하기 전의 최종 데이터

      //default formatStr 설정.
      if (!$.alopexUtil.isValid(formatStr)) {
        formatStr = 'yyyyMMdd';
      }

      var value_split = formatStr.split('');
      var dividerStr = '';

      // Format 타입 parsing
      while (i < value_split.length) {

        if (value_split[i] == 'y') {
          num_y = (formatStr.split('y').length - 1);
          i += num_y;
          value_type.push('y-' + num_y);

          if (isDateFormat(value_split[i])) {
            delegator.push('');
          }

        } else if (value_split[i] == 'M') {
          num_M = (formatStr.split('M').length - 1);
          i += num_M;
          value_type.push('M-' + num_M);

          if (isDateFormat(value_split[i])) {
            delegator.push('');
          }

        } else if (value_split[i] == 'd') {
          num_d = (formatStr.split('d').length - 1);
          i += num_d;
          value_type.push('d-' + num_d);

          if (isDateFormat(value_split[i])) {
            delegator.push('');
          }

        } else if (value_split[i] == 'E') {
          num_E = (formatStr.split('E').length - 1);
          i += num_E;
          value_type.push('E-' + num_E);

          if (isDateFormat(value_split[i])) {
            delegator.push('');
          }

        } else {
          dividerStr += value_split[i];

          if (isDateFormat(value_split[i + 1])) {
            delegator.push(dividerStr);
            dividerStr = '';
          }
          i++;
        }
      }

      /**
       * 해당 캐릭터가 DateFormat에 해당하는 캐릭터인지 여부 확인.
       * @param {string} char : 체크할 캐릭터.
       * @return {Boolean} DateFormat에 해당 하는 캐릭터 인지 여부.
       */
      function isDateFormat(char) {
        if (char == 'y' || char == 'M' || char == 'd' || char == 'E' ||
            char == undefined || char == null || char == '') {

          return true;
        } else {
          return false;
        }
      };

      // Format에 따른 Date data setting
      for (var i = 0; i < value_type.length; i++) {
        var temp = value_type[i].split('-');

        switch (temp[0]) {

        case 'y': // 연도 data setting
          var temp_year = param_date.getFullYear();

          if (temp[1] == '2') { // yy
            resultData.push(temp_year.toString().substring(2, 4));
          } else if (temp[1] == '4') { // yyyy
            resultData.push(temp_year.toString());
          } else {
            resultData.push(temp_year.toString());
          }
          break;

        case 'M': // 월 data setting
          var temp_month = param_date.getMonth();

          if (temp[1] == '1') { // M
            resultData.push(temp_month + 1);

          } else if (temp[1] == '2') { // MM
            resultData.push((temp_month + 1) < 10 ? '0' + (temp_month + 1) :
              (temp_month + 1));

          } else if (temp[1] == '3') { //MMM
            resultData.push(this._monthToStr(temp_month, false));

          } else if (temp[1] == '4') { //MMMM
            resultData.push(this._monthToStr(temp_month, true));

          } else {
            resultData.push((temp_month + 1) < 10 ?
                '0' + (temp_month + 1) : (temp_month + 1));
          }
          break;

        case 'd': // 일 data setting
          var temp_date = param_date.getDate();

          if (temp[1] == '1') { // d
            resultData.push(temp_date);

          } else if (temp[1] == '2') { // dd
            resultData.push(temp_date < 10 ? '0' + temp_date : temp_date);

          } else {
            resultData.push(temp_date < 10 ? '0' + temp_date : temp_date);
          }
          break;

        case 'E': // 요일 data setting
          var temp_day = param_date.getDay();

          if (temp[1] == '3') {
            resultData.push(this._dayToStr(temp_day, false));
          } else if (temp[1] == '4') {
            resultData.push(this._dayToStr(temp_day, true));
          } else {
            resultData.push(this._dayToStr(temp_day, false));
          }
          break;
        }
      }

      // 구분자와 Date data binding
      for (var i = 0; i < resultData.length; i++) {

        dateStr += resultData[i];

        if (delegator.length != 0) {
          if (i <= delegator.length) {
            dateStr += delegator[i];
          }
        }
      }

      this._callback(date, dateStr, certainDatesName);

    },

    /**
     * datepicker 닫기(내부 함수)
     */
    _close: function(e) {
      var obj = null;

      if (!$.alopexUtil.isValid(e)) {
        obj = this;
        
        if(obj.overlayElement){
          $(obj.overlayElement).remove();
        }
        if(!obj.isInline){
          $(obj.targetElem).focus();
          $(obj.calendarContainer).remove();
          $.datePickerMap.removeObjectById(obj.calendarContainerId);
        }

      } else {
        obj = $.datePickerMap.getObjectByNode(e.currentTarget);
        
        if(obj.overlayElement){
          $(obj.overlayElement).remove();
        }
        if(!obj.isInline){
          $(obj.targetElem).focus();
          $(obj.calendarContainer).remove();
          $.datePickerMap.removeObjectByNode(e.currentTarget);
        }
      }

      $(window).unbind('hashchange', obj._onHashChange);
      $(window).unbind('resize', obj._resizeHandler);
      $(document.body).unbind('pressed', obj._mouseDownHandler);
      $(document.body).unbind('keydown', obj._addKeyEvent);
      
    },
    
    _addKeyEvent: function(e){

      var that = e.data.obj;
      var currentAreaValue;
      var isCtrl = false;
      var isShift = false;
      
      that.currentArea = $(document.activeElement);
      currentAreaValue = $(that.currentArea)[0].value;

      //Ctrl 키 press 여부
      if (e.ctrlKey)
        isCtrl = true;
      
      //Shift 키 press 여부
      if (e.shiftKey)
        isShift = true;

      var code = (e.keyCode ? e.keyCode : e.which);

      switch(code){
      case 13: //enter
      case 32: //space
        $(that.currentArea).trigger('tap');
        
        if(!(currentAreaValue == 'prevYear' || currentAreaValue == 'nextYear' ||
            currentAreaValue == 'prevMonth' || currentAreaValue == 'nextMonth' ||
            $(that.currentArea).attr('data-type') == 'af-datepicker')){
          $(that.targetElem).focus();
        }
        
        e.preventDefault();
        e.stopPropagation();
        break;
      case 9: // tap
        
        if(isShift){
          if($(that.currentArea).attr('data-type') == 'af-datepicker'){
            $(that.targetElem).focus();
            that._close();
            e.preventDefault();
          }
        }else{
          if($(that.currentArea)[0].value == 'close'){
            $(that.calendarContainer).focus();
            e.preventDefault();
          }
        }
        break;
      case 37: //left
        var resultValue;
        
        if(currentAreaValue == 'prevYear' || currentAreaValue == 'nextYear' ||
            currentAreaValue == 'prevMonth' || currentAreaValue == 'nextMonth' ||
            currentAreaValue == 'close' || $(that.currentArea).attr('data-type') == 'af-datepicker'){
          
          that.currentArea = $(that.calendarContainer).find('a[class*=today]');
          currentAreaValue = $(that.currentArea)[0].value;
        }

        if((currentAreaValue-1) <= 0){
          $(that.prevMonth).trigger('tap');
          resultValue = that._getNumDaysOfMonth();
        }else{
          resultValue = currentAreaValue-1;
        }

        that.currentArea = $(that.calendarContainer).find('[value=' + resultValue + ']');
        $(that.currentArea).focus();

        e.preventDefault();
        break;
      case 39: //right
        var resultValue;
        
        if(currentAreaValue == 'prevYear' || currentAreaValue == 'nextYear' ||
            currentAreaValue == 'prevMonth' || currentAreaValue == 'nextMonth' ||
            currentAreaValue == 'close' || $(that.currentArea).attr('data-type') == 'af-datepicker'){
          
          that.currentArea = $(that.calendarContainer).find('a[class*=today]');
          currentAreaValue = $(that.currentArea)[0].value;
        }

        if((currentAreaValue+1) > that._getNumDaysOfMonth()){
          $(that.nextMonth).trigger('tap');
          resultValue = 1;
        }else{
          resultValue = currentAreaValue+1;
        }

        that.currentArea = $(that.calendarContainer).find('[value=' + resultValue + ']');
        $(that.currentArea).focus();

        e.preventDefault();
        break;
      case 38: //up
        var resultValue;
        
        if(currentAreaValue == 'prevYear' || currentAreaValue == 'nextYear' ||
            currentAreaValue == 'prevMonth' || currentAreaValue == 'nextMonth' ||
            currentAreaValue == 'close' || $(that.currentArea).attr('data-type') == 'af-datepicker'){
          
          that.currentArea = $(that.calendarContainer).find('a[class*=today]');
          currentAreaValue = $(that.currentArea)[0].value;
        }

        if((currentAreaValue-7) <= 0){
          $(that.prevMonth).trigger('tap');
          resultValue = that._getNumDaysOfMonth() + (currentAreaValue-7);
        }else{
          resultValue = currentAreaValue-7;
        }

        that.currentArea = $(that.calendarContainer).find('[value=' + resultValue + ']');
        $(that.currentArea).focus();

        e.preventDefault();
        break;
      case 40: //down
        var resultValue;
        
        if(currentAreaValue == 'prevYear' || currentAreaValue == 'nextYear' ||
            currentAreaValue == 'prevMonth' || currentAreaValue == 'nextMonth' ||
            currentAreaValue == 'close' || $(that.currentArea).attr('data-type') == 'af-datepicker'){
          
          that.currentArea = $(that.calendarContainer).find('a[class*=today]');
          currentAreaValue = $(that.currentArea)[0].value;
        }
        
        if((currentAreaValue+7) > that._getNumDaysOfMonth()){
          resultValue = (currentAreaValue+7) - that._getNumDaysOfMonth();// should be before trigger
          $(that.nextMonth).trigger('tap');
        }else{
          resultValue = currentAreaValue+7;
        }

        that.currentArea = $(that.calendarContainer).find('[value=' + resultValue + ']');
        $(that.currentArea).focus();

        e.preventDefault();
        break;
      case 27: // escape
        $(that.targetElem).focus();
        that._close();
        e.preventDefault();
        break;
      case 36: // home
        if(isCtrl){
          that.currentYearView = that._getCurrentYear();// '연도' 라벨의 값
          that.currentMonthView = that._getCurrentMonthToInteger();// '월' 라벨의 값

          that.calendarYear.innerHTML = that._addLocalePostfix(that.currentYearView, 'y');
          that.calendarMonth.innerHTML = that._addLocalePostfix(that._getMonthToString(true), 'm');

          while (that.calendarBody.hasChildNodes()) {
            that.calendarBody.removeChild(that.calendarBody.lastChild);
          }
          that.calendarBody.appendChild(that._renderCalendar());
          that._bindDayHandler();
          that.currentArea = $(that.calendarContainer).find('a[class*=today]');
          $(that.currentArea).focus();
        }else{
          that.currentArea = $(that.calendarContainer).find('[value=1]');
          $(that.currentArea).focus();
        }
        e.preventDefault();
        break;
      case 35: // end
        that.currentArea = $(that.calendarContainer).find('[value='+ that._getNumDaysOfMonth() + ']');
        $(that.currentArea).focus();
        e.preventDefault();
        break;
      case 33: //pageUp
        var resultValue;
        
        if(currentAreaValue == 'prevYear' || currentAreaValue == 'nextYear' ||
            currentAreaValue == 'prevMonth' || currentAreaValue == 'nextMonth' ||
            currentAreaValue == 'close' || $(that.currentArea).attr('data-type') == 'af-datepicker'){
          
          that.currentArea = $(that.calendarContainer).find('a[class*=today]');
          currentAreaValue = $(that.currentArea)[0].value;
        }

        if(isShift){
          $(that.prevYear).trigger('tap');
          
          //윤년처리 - 현재  2월 29일을 선택 중일 경우
          if(that.currentMonthView == 1 && currentAreaValue == 29){
            resultValue = 28;
          }else{
            resultValue = currentAreaValue;
          }
        }else{
          $(that.prevMonth).trigger('tap');
          
          if(that._getNumDaysOfMonth() < currentAreaValue){
            resultValue = that._getNumDaysOfMonth();
          }else{
            resultValue = currentAreaValue;
          }
        }

        that.currentArea = $(that.calendarContainer).find('[value=' + resultValue + ']');
        $(that.currentArea).focus();

        e.preventDefault();
        break;
      case 34: //pageDown
        var resultValue;
        
        if(currentAreaValue == 'prevYear' || currentAreaValue == 'nextYear' ||
            currentAreaValue == 'prevMonth' || currentAreaValue == 'nextMonth' ||
            currentAreaValue == 'close' || $(that.currentArea).attr('data-type') == 'af-datepicker'){
          
          that.currentArea = $(that.calendarContainer).find('a[class*=today]');
          currentAreaValue = $(that.currentArea)[0].value;
        }

        if(isShift){
          $(that.nextYear).trigger('tap');
          
          //윤년처리 - 현재  2월 29일을 선택 중일 경우
          if(that.currentMonthView == 1 && currentAreaValue == 29){
            resultValue = 28;
          }else{
            resultValue = currentAreaValue;
          }
        }else{
          $(that.nextMonth).trigger('tap');
          
          if(that._getNumDaysOfMonth() < currentAreaValue){
            resultValue = that._getNumDaysOfMonth();
          }else{
            resultValue = currentAreaValue;
          }
        }

        that.currentArea = $(that.calendarContainer).find('[value=' + resultValue + ']');
        $(that.currentArea).focus();

        e.preventDefault();
        break;
      default:
        if(!isCtrl && !isShift){
          $(that.targetElem).focus();
          that._close();
        }
        break;
      }
        
    },

    /**
     * Locale에 따른 년, 월, 일 데이터의 postfix를 add 하여 값을 리턴함.
     * @param {string} paramStr : postfix를 add할 대상이 되는 string data.
     * @param {string} type : 년, 월, 일 type 명시 ( 'y' | 'm' | 'd', | 'E').
     * @return {String} : postfix를 add한 결과 string.
     */
    _addLocalePostfix: function(paramStr, type) {

      var resultStr = paramStr + '';

      switch (type) {
      case 'y': //year
        resultStr += this.datePostfix[0];
        break;

      case 'm': //month
        resultStr += this.datePostfix[1];
        break;

      case 'd': //day
        resultStr += this.datePostfix[2];
        break;

      }

      return resultStr;

    },

    _getCurrentYear: function() {

      return this.currentDate.getFullYear();
    },

    _getCurrentMonthToInteger: function() {

      return this.currentDate.getMonth();
    },

    _getCurrentMonthToString: function(full) {
      var date = this.currentDate.getMonth();

      return this._monthToStr(date, full);
    },

    _getCurrentDay: function() {

      return this.currentDate.getDate();
    },

    _getMonthToInteger: function() {

      return this.currentMonthView;
    },

    _getMonthToString: function(full) {

      var date = this.currentMonthView;

      return this._monthToStr(date, full);
    },

    /**
     * 각 월의 일수를 return - 윤년 계산(2월).
     * @return {number} 각 월의 일수.
     */
    _getNumDaysOfMonth: function() {

      return (this._getMonthToInteger() == 1 &&
          !(this.currentYearView & 3) &&
          (this.currentYearView % 1e2 || !(this.currentYearView % 4e2))) ?
              29 : this.daysInMonth[this._getMonthToInteger()];
    },

    /**
     * html element 동적 rendering
     *
     * @param {string} nodeName rendering할 html태그명.
     * @param {json} attributes html 태그의 속성 : value.
     * @param {string} content html 태그 내의 내용(innerHTML).
     * @return {html} rendering된 html.
     */
    _render: function(nodeName, attributes, content) {
      var element;

      if (!(nodeName in this._renderCache)) {
        this._renderCache[nodeName] = document.createElement(nodeName);
      }

      element = this._renderCache[nodeName].cloneNode(false);

      if (attributes != null) {
        for (var attribute in attributes) {
          element[attribute] = attributes[attribute];
        }
      }

      if (content != null) {
        if (typeof (content) == 'object') {
          element.appendChild(content);
        } else {
          element.innerHTML = content;
        }
      }

      return element;
    },

    _monthToStr: function(date, full) {
      return ((full == true) ? this.months[date] :
        ((this.months[date].length > 3) ? this.months[date].substring(0, 3) :
            this.months[date]));
    },

    _dayToStr: function(date, full) {
      return ((full == true) ? this.weekdays[date] :
        ((this.weekdays[date].length > 3) ? this.weekdays[date].substring(
              0, 3) : this.weekdays[date]));
    },

    /**
     *
     * 연도 컨트롤 버튼의 click 시
     * - 1900~2100년의 범위만 허용
     */
    _clickYear: function() {

      if (this.currentYearView < 1900) {

        //허용 범위 중 Minimum
        this.currentYearView = 1900;
      } else if (this.currentYearView > 2100) {

        //허용 범위 중 Maximum
        this.currentYearView = 2100;
      }
      
      //min, max date 처리
      if(this.currentYearView == this.minDate.getFullYear() &&
          this.currentMonthView < this.minDate.getMonth()){
        this.currentMonthView = this.minDate.getMonth();
      }
      
      if(this.currentYearView == this.maxDate.getFullYear() &&
          this.maxDate.getMonth() < this.currentMonthView){
        this.currentMonthView = this.maxDate.getMonth();
      }
        
      this.calendarYear.innerHTML = this._addLocalePostfix(
          this.currentYearView, 'y');
      this.calendarMonth.innerHTML = this._addLocalePostfix(this
          ._getMonthToString(true), 'm');

      // '일' 영역 re-rendering
      while (this.calendarBody.hasChildNodes()) {
        this.calendarBody.removeChild(this.calendarBody.lastChild);
      }
      this.calendarBody.appendChild(this._renderCalendar());
      this._bindDayHandler();

      return false;
    },

    /**
     * 월 컨트롤 버튼의 click 시
     */
    _clickMonth: function() {

      if (this.currentMonthView < 0) {
        this.currentYearView--;

        if (this.currentYearView < 1900) {
          this.currentYearView = 1900;
        }

        // '12월' 부터 다시 시작.
        this.currentMonthView = 11;

        this.calendarYear.innerHTML = this._addLocalePostfix(
            this.currentYearView, 'y');
        this.calendarMonth.innerHTML = this._addLocalePostfix(this
            ._getMonthToString(true), 'm');

      } else if (this.currentMonthView > 11) {
        this.currentYearView++;

        if (this.currentYearView > 2100) {
          this.currentYearView = 2100;
        }

        // '1월' 부터 다시 시작.
        this.currentMonthView = 0;

        this.calendarYear.innerHTML = this._addLocalePostfix(
            this.currentYearView, 'y');
        this.calendarMonth.innerHTML = this._addLocalePostfix(this
            ._getMonthToString(true), 'm');

      } else {
        this.calendarMonth.innerHTML = this._addLocalePostfix(this
            ._getMonthToString(true), 'm');
      }

      // '일' 영역 re-rendering
      while (this.calendarBody.hasChildNodes()) {
        this.calendarBody.removeChild(this.calendarBody.lastChild);
      }
      this.calendarBody.appendChild(this._renderCalendar());
      this._bindDayHandler();

      return false;
    },

    /**
     * 연도 컨트롤 버튼의 click handler 설정.
     */
    _bindYearHandler: function() {
      var that = this;
      
      $(that.prevYear).unbind('tap');
      $(that.nextYear).unbind('tap');
      
      //minDate의 year가 현재 year와 같을 경우
      if(this.minDate.getFullYear() == this.currentYearView){
        $(that.prevYear).children().css('visibility', 'hidden');
        
      }else{
        $(that.prevYear).children().css('visibility', 'visible');
        
        $(that.prevYear).bind('tap', function(e) {
          var obj = $.datePickerMap.getObjectByNode(e.currentTarget);
          obj.currentYearView--;
          return obj._clickYear();
        });
        
        $(that.prevYear).children().bind('focus', function(e) {
          $(this).trigger('hoverstart');
        });
        
        $(that.prevYear).children().bind('focusout', function(e) {
          $(this).trigger('hoverend');
        });
        
        $.alopexWidget.object.addHighlight($(that.prevYear).children()[0]);
      }

      //maxDate의 year가 현재 year와 같을 경우
      if(this.maxDate.getFullYear() == this.currentYearView){
        $(that.nextYear).children().css('visibility', 'hidden');
       
      }else{
        $(that.nextYear).children().css('visibility', 'visible');
      
        $(that.nextYear).bind('tap', function(e) {
          var obj = $.datePickerMap.getObjectByNode(e.currentTarget);
          obj.currentYearView++;
          return obj._clickYear();
        });
        
        $(that.nextYear).children().bind('focus', function(e) {
          $(this).trigger('hoverstart');
        });
        
        $(that.nextYear).children().bind('focusout', function(e) {
          $(this).trigger('hoverend');
        });
        
        
        $.alopexWidget.object.addHighlight($(that.nextYear).children()[0]);
      }

    },

    /**
     * 월 컨트롤 버튼의 click handler 설정.
     */
    _bindMonthHandler: function() {
      var that = this;

      $(that.prevMonth).bind('tap', function(e) {
        var obj = $.datePickerMap.getObjectByNode(e.currentTarget);
        obj.currentMonthView--;
        return obj._clickMonth();
      });
      
      $(that.prevMonth).children().bind('focus', function(e) {
        $(this).trigger('hoverstart');
      });
      
      $(that.prevMonth).children().bind('focusout', function(e) {
        $(this).trigger('hoverend');
      });

      $(that.nextMonth).bind('tap', function(e) {
        var obj = $.datePickerMap.getObjectByNode(e.currentTarget);
        obj.currentMonthView++;
        return obj._clickMonth();
      });
      
      $(that.nextMonth).children().bind('focus', function(e) {
        $(this).trigger('hoverstart');
      });
      
      $(that.prevMonth).unbind('tap');
      $(that.nextMonth).unbind('tap');
      
      //minDate의 month가 현재 month와 같을 경우
      if(this.minDate.getMonth() == this.currentMonthView && this.minDate.getFullYear() == this.currentYearView){
        $(that.prevMonth).children().css('visibility', 'hidden');
        
      }else{
        $(that.prevMonth).children().css('visibility', 'visible');
        
        $(that.prevMonth).bind('tap', function(e) {
          var obj = $.datePickerMap.getObjectByNode(e.currentTarget);
          obj.currentMonthView--;
          return obj._clickMonth();
        });
        
        $(that.prevMonth).children().bind('focus', function(e) {
          $(this).trigger('hoverstart');
        });
        
        $(that.prevMonth).children().bind('focusout', function(e) {
          $(this).trigger('hoverend');
        });
        
        $.alopexWidget.object.addHighlight($(that.prevMonth).children()[0]);
      }

      //maxDate의 month가 현재 month와 같을 경우
      if(this.maxDate.getMonth() == this.currentMonthView && this.maxDate.getFullYear() == this.currentYearView){
        $(that.nextMonth).children().css('visibility', 'hidden');
        
      }else{
        $(that.nextMonth).children().css('visibility', 'visible');
        
        $(that.nextMonth).bind('tap', function(e) {
          var obj = $.datePickerMap.getObjectByNode(e.currentTarget);
          obj.currentMonthView++;
          return obj._clickMonth();
        });
        
        $(that.nextMonth).children().bind('focus', function(e) {
          $(this).trigger('hoverstart');
        });
        
        $(that.nextMonth).children().bind('focusout', function(e) {
          $(this).trigger('hoverend');
        });
        
        $.alopexWidget.object.addHighlight($(that.nextMonth).children()[0]);
      }
    },

    /**
     * 일 버튼의 click handler 설정.
     */
    _bindDayHandler: function() {
      var that = this;
      var days = this.calendarBody.getElementsByTagName('a');

      for (i = 0, x = days.length; i < x; i++) {
        
        /*if(this._isBelowMinDate(days[i].innerHTML) || this._isAboveMaxDate(days[i].innerHTML)){
          continue;
        }*/
        
        $.alopexWidget.object.addHighlight(days[i]);

        $(days[i]).bind('focus', function(e) {
          $(this).trigger('hoverstart');
        });
        
        $(days[i]).bind('focusout', function(e) {
          $(this).trigger('hoverend');
        });
        
        $(days[i]).bind('tap', function(e) {
          var obj = $.datePickerMap.getObjectByNode(e.currentTarget);

          var date = {
              'year': obj.currentYearView,
              'month': obj.currentMonthView + 1,
              'day': this.innerHTML
          };
          
          //min, maxDate 이외의 날짜를 클릭할 경우 close 하지 않고 유지 
          if(obj._isBelowMinDate(this.innerHTML) || obj._isAboveMaxDate(this.innerHTML)){
            e.preventDefault();
            e.stopPropagation();
            return false;
          }

          var certainDatesInfo = that._isCertainDate(this.innerHTML);

          if (certainDatesInfo) {
            obj.getDateByFormat(date, obj.dateFormat, certainDatesInfo.name);
          } else {
            obj.getDateByFormat(date, obj.dateFormat, false);
          }

          if(!obj.isInline){
            if (!certainDatesInfo || certainDatesInfo.isClickToClose) {
              obj._close(e);
            }
          }

          e.preventDefault();
          e.stopPropagation();
          return false;
        });
        
      }
    },

    /**
     * 요일 영역 html 생성 및 바인딩
     * @return {html} 요일 영역의 html element.
     */
    _renderWeekdays: function() {
      var that = this;
      var html = document.createDocumentFragment();

      for (var i = 0; i < that.weekdays.length; i++) {

        //일요일(Sun)을 빨간색으로 표시
        if (i == 0) {
          html.appendChild(that._render('th', {
            className: 'weekdays holiday'
          }, that.weekdays[i].substring(0, 3)));
        }else if(i!=0 && i%6==0){
          html.appendChild(that._render('th', {
            className: 'weekdays saturday'
          }, that.weekdays[i].substring(0, 3)));
        }else {
          html.appendChild(that._render('th', {className: 'weekdays'}, that.weekdays[i].substring(0,
              3)));
        }
      }
      return html;
    },

    /**
     * 일 영역 구성.
     * @return {html} '일'영역을 구성한 html element.
     */
    _renderCalendar: function() {

      var firstOfMonth = new Date(this.currentYearView, this.currentMonthView,
          1).getDay();
      var numDays = this._getNumDaysOfMonth();
      var dayCount = 0;
      var html = document.createDocumentFragment();
      var row = this._render('tr');
      var element;

      //첫번째 일 이전의 이전달 '일' 영역에 대한 공백
      for (var i = 1; i <= firstOfMonth; i++) {
        row.appendChild(this._render('td', {}, '&nbsp;'));
        dayCount++;
      }

      for (var i = 1; i <= numDays; i++) {

        if (dayCount == 7) {
          html.appendChild(row);
          row = this._render('tr');
          dayCount = 0;
        }

        //일요일일때 날짜를 빨간색으로 표시
        if (dayCount == 0) {
          element = this
                  ._render(
                      'td', {},
                      this._render('a', {
                        className: (i == this._getCurrentDay() &&
                            this.currentMonthView ==
                              this._getCurrentMonthToInteger() &&
                              this.currentYearView ==
                                this._getCurrentYear()) ? 'day today' :
                                  'day holiday', value : i, href:'#'+i}, i));
        } else if(dayCount == 6){
          element = this
                  ._render(
                      'td', {},
                      this._render('a', {
                        className: (i == this._getCurrentDay() &&
                            this.currentMonthView ==
                              this._getCurrentMonthToInteger() &&
                              this.currentYearView ==
                                this._getCurrentYear()) ? 'day today' :
                                  'day saturday', value : i, href:'#'+i}, i));
        } else {
          element = this
                  ._render(
                      'td', {},
                      this._render('a', {
                        className: (i == this._getCurrentDay() &&
                            this.currentMonthView == this
                            ._getCurrentMonthToInteger() &&
                            this.currentYearView ==
                              this._getCurrentYear()) ? 'day today' : 'day'
                                , value : i, href:'#'+i}, i));
        }

        var certainDateInfo = this._isCertainDate(i);

        if (certainDateInfo) {
          $(element).children().addClass(certainDateInfo.styleClass);
        }
        
        if(this._isBelowMinDate(i) || this._isAboveMaxDate(i)){
          $(element).children().css('opacity', '0.3');
          $(element).children().css('cursor', 'default');
          $(element).children().attr('tabindex', '-1');
        }

        row.appendChild(element);

        dayCount++;
      }

      //마지막 일 이후의 다음달 '일' 영역에 대한 공백
      for (i = 1; i <= (7 - dayCount); i++) {
        row.appendChild(this._render('td', {}, '&nbsp;'));
      }

      html.appendChild(row);
      
      this._bindYearHandler();
      this._bindMonthHandler();

      return html;
    },

    /**
     * DatePicker 초기화
     */
    _initialise: function() {

      var that = this;

      this.currentYearView = this._getCurrentYear();// '연도' 라벨의 값
      this.currentMonthView = this._getCurrentMonthToInteger();// '월' 라벨의 값

      this.calendarContainer = this._render('div', {className: 'af-datepicker'});
      $(this.calendarContainer).attr('data-type', 'af-datepicker');
      
      if(this.isInline){
        $(this.calendarContainer).attr('data-datepicker-inline', 'true');
      }

      //default 테마 적용.
      $(this.calendarContainer).addClass(this.datePickerTheme);

      //중복 생성 방지를 위해 datepicker_ 를 prefix로 id 부여.
      this.calendarContainer.id = this.calendarContainerId;

      //dstepicker의 head(header) 구성
      var header = this._render('div', {
        className: 'header'
      });
      var subheader01 = this._render('div', {
        className: 'subHeader'
      });
      var subheader02 = this._render('div', {
        className: 'subHeader'
      });

      this.prevYear = this._render('span', {
        className: 'prev-year'
      }, this._render('a', {className: 'control', value: 'prevYear', href:'#0', title:this.descPrevYear}, '&lt;'));
      this.calendarYear = this._render('span', {
        className: 'current-year'
      }, this._addLocalePostfix(this.currentYearView, 'y'));
      this.nextYear = this._render('span', {
        className: 'next-year'
      }, this._render('a', {className: 'control',value: 'nextYear', href:'#0', title:this.descNextYear
      }, '&gt;'));

      this.prevMonth = this._render('span', {
        className: 'prev-month'
      }, this._render('a', {className: 'control',value: 'prevMonth',  href:'#0', title:this.descPrevMonth
      }, '&lt;'));
      this.calendarMonth = this._render('span', {
        className: 'current-month'
      }, this._addLocalePostfix(this._getMonthToString(true), 'm'));
      this.nextMonth = this._render('span', {
        className: 'next-month'
      }, this._render('a', {className: 'control',value: 'nextMonth',  href:'#0', title:this.descNextMonth
      }, '&gt;'));
      
      //subheader에 연도 영역 append
      subheader01.appendChild(this.prevYear);
      subheader01.appendChild(this.calendarYear);
      subheader01.appendChild(this.nextYear);

      //subheader에 월 영역 append
      subheader02.appendChild(this.prevMonth);
      subheader02.appendChild(this.calendarMonth);
      subheader02.appendChild(this.nextMonth);

      //inline style
      if(!this.isInline){
        this.btn_close = this._render('span', {
          className: 'btn-close'
        }, this._render('a', {className: 'control', value: 'close',  href:'#0', title:this.descClose
        }, 'X'));
        $(this.btn_close).children().bind('tap', function(e) {
          that._close(e);
        });
        $(this.btn_close).children().bind('focus', function(e) {
          $(this).trigger('hoverstart');
        });
        
        $(this.btn_close).children().bind('focusout', function(e) {
          $(this).trigger('hoverend');
        });
        
        $.alopexWidget.object.addHighlight($(this.btn_close).children()[0]);
      }else{
        $(subheader01).css("width","50%");
        $(subheader02).css("width","50%");
        $(this.calendarYear).css("width","73%");
        $(this.calendarMonth).css("width","73%");
      }

      //header에 subheader, 닫기버튼 append
      header.appendChild(subheader01);
      header.appendChild(subheader02);

      //일 영역 생성
      var calendar = this._render('table', {}, this._render('thead', {}, this
          ._render('tr', {}, this._renderWeekdays())));
      this.calendarBody = this._render('tbody', {}, this._renderCalendar());

      calendar.appendChild(this.calendarBody);

      this.calendarContainer.appendChild(header);
      this.calendarContainer.appendChild(calendar);
      
      //inline style
      if(!this.isInline){
        this.calendarContainer.appendChild(this.btn_close);
      }

      //inline style
      if(!this.isInline){
        $('body').append(this.calendarContainer);
      }else{
        $(this.targetElem).append(this.calendarContainer);
      }
      
      this._setPosition(this);

    },
    
    _setPosition: function(obj){
      
      if(obj.isInline){
        return;
      }
      
      var dialog = $.alopexWidget.dialog;
      var zIndex = 1006;
      if (dialog != null && window.afDialogNumber > 0) {
        zIndex = dialog.maxZindex + 1;
      }
      //for mobile phone type
      if(window.browser == 'mobile' && $(window).width() < 768){
        
        var centerTop = ($(window).scrollTop()) ? $(window).scrollTop() +
            ($(window).height() - obj.calendarContainer.offsetHeight) / 2 :
              document.body.scrollTop +
              ($(window).height() - obj.calendarContainer.offsetHeight) / 2;

        var centerLeft = ($(window).scrollLeft()) ? $(window).scrollLeft() +
            ($(window).width() - obj.calendarContainer.offsetWidth) / 2 :
              document.body.scrollLeft +
              ($(window).width() - obj.calendarContainer.offsetWidth) / 2;
            
        
        obj.calendarContainer.style.cssText = 'display: none; position: absolute; z-index: ' + zIndex +'; top: ' +
        centerTop + 'px; left: ' + centerLeft + 'px;';
        
        if(!obj.overlayElement){
          obj.overlayElement = document.createElement("div");
        }
        
        var overlayHeight = $(document).height();
        
        obj.overlayElement.style.cssText = 'width:100%; position:absolute;' 
          + 'left:0; margin:0; padding:0; background:#000; opacity:0.5; z-index:1004;'
          + 'top:0px;' + 'height:'+ overlayHeight + 'px;';
        $('body').append(obj.overlayElement);
        
      }else{

        var topValue = $(obj.targetElem).offset().top + obj.targetElem.offsetHeight + 5;
        var leftValue = $(obj.targetElem).offset().left;
        
        //DatePicker가 현재window 너비 밖으로 벗어 날 경우 
        if((leftValue + $(obj.calendarContainer).width()) > $(window).width()){
          leftValue -= (leftValue + $(obj.calendarContainer).width() + 10) - $(window).width();
        }
        
        obj.calendarContainer.style.cssText =
          'display: none; position: absolute; z-index:' + zIndex + '; top: ' +
          topValue + 'px; left: ' + leftValue + 'px;';
      }
      
      $(obj.calendarContainer).css('display', 'block');
    },

    /**
     * 같은 DatePicker가 이미 열려있는지 체크
     * @param {string} id : DatePicker 위치의 기준이 되는 target element의 id.
     * @return {Boolean} : DatePicker가 현재 열려 있는지 여부.
     */
    _isOpened: function(id) {

      var objId = 'datepicker_' + id;

      if ($.datePickerMap.datePickerObj.hasOwnProperty(objId)) {
        return true;
      } else {
        return false;
      }
    },

    _mouseDownHandler: function(e) {
      
      var isDatePicker = false;
      var temp = $(e.target);

      for (var i = 0; i < 7; i++) {
        
        if (temp.attr('data-type') == 'af-datepicker' 
          && temp.attr('data-datepicker-inline') != 'true') {
          isDatePicker = true;
          break;
        }

        temp = temp.parent();
      }

      if (!isDatePicker) {
        for (var key in $.datePickerMap.datePickerObj) {
          $.datePickerMap.datePickerObj[key]._close();
        }
      }else {
        return;
      }
    },

    _resizeHandler: function(e) {
      for (var key in $.datePickerMap.datePickerObj) {
        $.datePickerMap.datePickerObj[key]._setPosition( $.datePickerMap.datePickerObj[key]);
      }
    },
    
    _onHashChange: function(e) {
      for (var key in $.datePickerMap.datePickerObj) {
        $.datePickerMap.datePickerObj[key]._close();
      }
    }

  };

  /**
   * datepicker 열기
   */
  $.fn.showDatePicker = function(callback, option) {

    if (!$.alopexUtil.isValid(callback) || typeof (callback) != 'function') {
      console.log('[DatePicker Error] callback is null or' +
          'it is not function type');
      return;
    }
    
    if (!$.alopexUtil.isValid(option)) {
      option = {};
    }

    for (var key in $.datePickerMap.datePickerObj) {
        if (!option.inline) {
          $.datePickerMap.datePickerObj[key]._close();
        }
    }

    var that = $.extend(true, {}, $.datePicker);

    that.targetElem = this[0];
    that._callback = callback;
    that.calendarContainerId = 'datepicker_' + this[0].id;

    that.setDefaultDate(option);
    that.setLocale(option);
    that.setFormat(option);
    that.setCertainDates(option);
    that.setThemeClass(option);
    that.setMinDate(option);
    that.setMaxDate(option);
    that.setInline(option);

    that._initialise();
    that._bindDayHandler();
    
    //not inline style
    if(!that.isInline){
      //for web or tablet type
      if(!(window.browser == 'mobile' && $(window).width() < 768)){
        $(document.body).bind('pressed', that._mouseDownHandler);
        $(window).bind('hashchange', that._onHashChange);
      }
      
      $(window).bind('resize', that._resizeHandler);
      $(document.body).bind('keydown', {obj : that},that._addKeyEvent);
      
      //IE10에서 호환성 보기로 로드 할 경우 tabindex를 0으로 지정 후 focus()시 에러 발생하는 브라우저 버그 처리
      if(navigator.userAgent.toLowerCase().indexOf('trident/6.0') == -1){
        $(that.calendarContainer).attr('tabindex', 0);
      }
      $(that.calendarContainer).focus();

      $(that.targetElem).bind('pressed', function(e){e.stopPropagation();});
    }
    
    $(that.calendarContainer).bind('selectstart', function(e){return false;});
    $(that.calendarContainer).bind('dragstart', function(e){return false;});

    $.datePickerMap.setObject(that.calendarContainerId, that);
  };

  /**
   * datepicker 닫기
   */
  $.fn.closeDatePicker = function() {

    if ($.datePicker._isOpened(this[0].id)) {
      var obj = $.datePickerMap.getObjectById(this[0].id);
      obj._close();
    }
  };

	  
  $.fn.hasEventHandler = function(event, handler) {
    var registeredEventList = $._data(window, "events");
    if(registeredEventList != undefined && registeredEventList[event] != undefined) {
      var handlerList = registeredEventList[event];
      for(var i=0; i<handlerList.length; i++) {
        if(handlerList[i].handler == handler) {
          return true;
        }
      }
    }
    return false;
  };
  
	

  $.alopexready = function(handler, condition) {
    $.alopex.entryFunctions.push({callback: handler, condition: (condition == undefined)? function() {return true;} : condition});
    if ($.alopex.domready) {
      $.alopex.start();
    }
  };

  $(document).ready($.alopex.init); // DOMContentLoaded // 위치 뒤로 이동
//  $(document).css('opacity', '0');

})(jQuery);
/*!
* Copyright (c) 2012 SK C&C Co., Ltd. All rights reserved.
*
* This software is the confidential and proprietary information of SK C&C.
* You shall not disclose such confidential information and shall use it
* only in accordance with the terms of the license agreement you entered into
* with SK C&C.
*
* Alopex UI Javascript Event Module.
*
* Date : 20130207
*/
(function($) {
  var useClickFallback = true;
  var eventns = '.alopexUiEventModel';
  //console.log('loaded');
  var state = {}, currentState = {}, istouch, statecount = 0, trigger = {},
  timeoutTrigger = [], threshold = {}, event = {}, eventCancelPair = {},
  allEvent = [], movingEvent = [], processor = {},
  startevent, moveevent, endevent;

  function createState() {
    var obj = {};
    obj.id = statecount++;
    obj.entry = obj.doing = obj.exit = null;
    obj.transition = [];
    return obj;
  }

  function createTransition(to, trigger, guard, effect) {
    var obj = {};
    obj.to = to || null;
    obj.trigger = trigger || null;
    obj.guard = guard || null;
    obj.effect = effect || null;
    return obj;
  }

  //system base setup
  istouch = 'ontouchstart' in window;
  if(istouch) useClickFallback = false;
  if(false) {
    startevent = (istouch ? 'touchstart' : 'mousedown')+eventns;
    moveeevent = (istouch ? 'touchmove' : 'mousemove')+eventns;
    endevent = istouch ? 'touchend'+eventns+' touchcancel'+eventns : 'mouseup'+eventns;
  } else {
    startevent = istouch ? 'touchstart' : 'mousedown';
    startevent += eventns;
    startevent += ' keydown' + eventns;
    moveevent = istouch ? 'touchmove' : 'mousemove';
    moveevent += eventns;
    endevent = istouch ? 'touchend'+eventns+' touchcancel'+eventns : 'mouseup'+eventns;
    endevent += ' keyup' + eventns;
  }
  //define state transition trigger
  trigger.down = null;
  trigger.move = null;
  trigger.up = null;
  trigger.timeout = null;

  for (var name in trigger) {
    trigger[name] = name;
  }

  //define supported event
  event.pressed = null;
  event.unpressed = null;
  event.move = null;
  //hover event
  event.hoverstart = null;
  event.hoverend = null;
  event.hovering = null;
  //tap event
  event.tap = null;
  event.singletap = null;
  event.doubletap = null;
  event.tripletap = null;
  event.longtap = null;
  //drag event(based on HTML5 drag&drop api behavior)
  event.drag = null;
  event.dragend = null;
  event.dragstart = null;
  event.dragenter = null;
  event.dragleave = null;
  event.dragover = null;
  event.drop = null;
  //swipe event
  event.swipe = null;
  event.swipemove = null;
  event.swipecancel = null;
  event.swipeleft = null;
  event.swiperight = null;
  event.swipedown = null;
  event.swipeup = null;
  //transform event
  event.pinch = null;
  event.rotate = null;
  event.transform = null;
  event.transformmove = null;
  //general gesture event
  event.gesturestart = null;
  event.gesturechange = null;
  event.gestureend = null;

  for (var name in event) {
    event[name] = name;
  }

  //20121108 tap과 singletap에 대한 개발자 가이드의 문제 ->
  //tap의 이름을 singletap으로 하고, singletap을 onetimetap이름으로 정의한다.
  event.tap = 'singletap';
  event.singletap = 'onetimetap';

  for (var name in event) {
    allEvent.push(event[name]);
  }
  //tap-singletap 이벤트 처리 관련 문제.
  allEvent.push('tap');

  movingEvent = [event.drag, event.dragenter, event.dragleave, event.dragover,
      event.dragstart, event.dragend, event.drop, event.swipe, event.swipemove,
      event.swipecancel, event.pinch, event.rotate, event.transform,
      event.transformmove, event.gesturestart, event.gesturechange,
      event.gestureend];

  //이벤트 비정상 종료시, 이벤트 시작-종료 처리를 위해 사용.
  eventCancelPair[event.swipe] = event.swipecancel;
  eventCancelPair[event.swipemove] = event.swipecancel;
  eventCancelPair[event.swiperight] = event.swipecancel;
  eventCancelPair[event.swipeleft] = event.swipecancel;
  eventCancelPair[event.swipedown] = event.swipecancel;
  eventCancelPair[event.swipeup] = event.swipecancel;
  eventCancelPair[event.pressed] = event.unpressed;
  eventCancelPair[event.hoverstart] = event.hoverend;
  eventCancelPair[event.hovering] = event.hoverend;

  threshold.move_d = 5; // 단위 : px
  threshold.swipe_d = 100; // 단위 : px
  threshold.swipe_v = 100; // 단위 : px/sec
  threshold.longtap_t = 750; // 단위 : ms
  threshold.ntap_t = 250; // 단위 : ms.
  threshold.hover_v = 100;// 단위 : px/sec

  /****************************************************
   * 엘리먼트에 직접 가해지는 raw 이벤트 및 해당 엘리먼트 처리에 대한 low-level함수
   ***************************************************/
  //특정 element로 부터 data-event 값을 이용하여 이벤트 핸들러를 생성한다.
  var attrEventHandler = function(elem, name) {
    if(!elem || !name) {
      return null;
    }
    if(!$(elem).attr('data-'+name)) {
      return null;
    }
    var func = new Function('event, aevent', ''+
        $(elem).attr('data-'+name) + ';');
    return func;
  };
  
  var downHandler = function(e) {
    var returnValue = true;
    var actualtrigger = trigger.down;

    if (e.which && !(e.which == 1 || e.which == 13 || e.which == 32)) {
      return;
    }
    if(e.type == 'keydown' && e.target.tagName == "A") {
      //$(e.target).one('click', function(ev){ev.preventDefault();});
    }
    if (e.type == 'touchstart' && e.originalEvent.touches.length > 1) {
      //touch 손가락 증가에 대해서 move로 처리.
      actualtrigger = trigger.move;
    }
    advanceState(actualtrigger, e);
    return returnValue;
  };

  var lp = null;
  var moveHandler = function(e) {
    if(!lp) {
      lp = {};
      lp.x = e.pageX;
      lp.y = e.pageY;
    } else {
      if(lp.x === e.pageX && lp.y === e.pageY) {
        return;
      }
      lp.x = e.pageX;
      lp.y = e.pageY;
    }
    advanceState(trigger.move, e);
  };

  var upHandler = function(e) {
    var actualtrigger = trigger.up;
    if (e.which && !(e.which == 1 || e.which == 13 || e.which == 32)) {
      //console.log(e.which);
      return;
    }
    if (e.type == 'touchend' && e.originalEvent.touches.length > 0) {
      //touch 손가락 감소에 대해서 move로 처리.
      actualtrigger = trigger.move;
    }
    advanceState(actualtrigger, e);
  };

  var isStayingStill = function(e) {
    if ($(currentState.pressedElement)[0] == $(e.target)[0]) {
      return true;
    }
    return false;
  };

  var isMovedOverElement = function(e) {
    if (!currentState.currentElement) {
      return false;
    }
    if (currentState.currentElement != currentState.previousElement) {
      return true;
    }
    return false;
  };

  var extendEventObject = function(eobj, origin) {
    $.each(['target','pageX','pageY','which','metakey',
            'relatedTarget', 'clientX', 'clientY','offsetX','offsetY'], 
      function(idx, val) {
        eobj[val] = origin[val];
      }
    );
    eobj.originalEvent = origin;
    eobj.isOriginalDefaultPrevented = function() {
      return !!this.originalDefaultPrevented;
    };
    eobj.preventOriginalDefault = function() {
      this.originalDefaultPrevented = true;
    };
    eobj.isOriginalPropagationStopped = function() {
      return !!this.originalPropagationStopped;
    };
    eobj.stopOriginalPropagation = function() {
      this.originalPropagationStopped = true;
    };
  };

  //마우스/키보드 외의 수단에서 인위적으로 .click()을 실행하는 경우에 대한 우회책 구현. 
  //data-tap attribute를 가진 엘리먼트에 대한 click에서 이를 처리. 
  $(function(){
    if(!useClickFallback) return;
    $(document.body)
      .off('.alopexworkaround')
      .on('click.alopexworkaround', '[data-tap]', function(e) {
      	var tagName = String(this.tagName).toUpperCase();
    	if(tagName === "LABEL") return;
    	if(tagName === "INPUT") {
    	  var type = String(this.type).toLowerCase();
    	  if(type === "checkbox") return;
    	  if(type === "radio") return;
    	} 
        //data-tap에 의해 이벤트가 발생했을경우에는 실행할 필요가 없다.
        var $this = $(this);
        var tapped = $this.data('alopex-ui-data-tap');
        $this.data('alopex-ui-data-tap',null);
        if(tapped) { 
          return;
        }
        $this.data('alopex-ui-data-tap-keyup', true);
        var attrEvent = attrEventHandler(this, event.tap);
        if($.isFunction(attrEvent)) {
          e.type = event.tap;
          return attrEvent.call(this, e);
        }
        if(event.tap !== "tap") {
          attrEvent = attrEventHandler(this, "tap");
          if($.isFunction(attrEvent)) {
            e.type = "tap";
            return attrEvent.call(this, e);
          }
        }
      });
  });
  
  var triggerEvent = function(e, elem, eventname) {
    var arg = Array.prototype.slice.call(arguments, 3),
        el = $(elem), eobj = $.Event(eventname);
    if (arg.length && typeof arg[0] == typeof [] && arg[0].length > 0) {
      arg = arg[0];
    }
    //touchcancel이 호출된 경우 무조건 현재 이벤트의 cancelpair를 호출하도록 한다.
    if(e.type=='touchcancel') {
      triggerCancel(e);
      return;
    }
    //data attribute event handler를 생성하고, 일회용으로 bind 함.
    var attrEvent = attrEventHandler(elem, eventname);
    if(attrEvent && $ === window['jQuery']) { //20130323 attribute custom event의 이중실행 방지
      el.one(eventname, attrEvent);
      if(useClickFallback && eventname === "tap") {
        el.data('alopex-ui-data-tap', true);
        if(e.type === "keyup" && el.data('alopex-ui-data-tap-keyup')) {
          el.off(eventname, attrEvent);
          el.data('alopex-ui-data-tap-keyup', null);
          el.data('alopex-ui-data-tap', null);
        }
      }
    }
    
    //singletap-tap 구분에 대한 문제 처리 위한 임시 코드.
    //event.tap이 singletap으로 정의되어 있을 경우 tap이벤트도 같이 발생시키도록 한다.
    if(eventname == event.tap && event.tap == 'singletap') {
      var targ = Array.prototype.slice.call(arguments, 0);
      targ[2] = 'tap';
      triggerEvent.apply(null, targ);
    }
    extendEventObject(eobj, e);
    //event extension에서 우회처리하기 위한 이벤트발생시점의 original type 정보 지정
    if(eventname === "tap" || eventname === "singletap") {
      eobj.origType = e.type;
    }
    el.trigger(eobj, arg);

    if (eobj.isOriginalDefaultPrevented()) {
      try {
        e.preventDefault();
      } catch (err) {
      }
    }
    if (eobj.isDefaultPrevented()) {
      //anchor에 대해서 preventDefault가 지정된 경우,
      //click핸들러에 일회용 preventDefault핸들러를 연결한다.
      for (var i = 0; i < el.length; i++) {
        if (el[i].tagName == 'A' ||
            (el[i].tagName == 'BUTTON' && el[i].type == 'submit')) {
          $(el[i]).one('click', function(e) {
            e.preventDefault();
          });
        }
      }
    }
    if (eobj.isOriginalPropagationStopped()) {
      try { //originalEvent가 invalidated된 경우 IE에서 Exception 발생
        e.stopPropagation();
      } catch (err) {
      }
    }

    if (eventCancelPair[eventname]) {
      var c = eventCancelPair[eventname];
      arg[0] = c;
      currentState.needCancel[c] = {
        elem: elem,
        arg: arg
      };
    }
  };

  var triggerCancel = function(e) {
    for (var prop in currentState.needCancel) {
      var c = currentState.needCancel[prop];
      var eobj = $.Event(c.arg[0]);
      extendEventObject(eobj, e);
      $(c.elem).trigger(eobj, c.arg.slice(1));
    }
    delete currentState.needCancel;
    currentState.needCancel = {};
  };

  /****************************************************
   * Timeout Trigger와 관련된 함수.
   ***************************************************/
  var registerTimeoutFromState = function(st, e) {
    for (var i = 0; i < st.transition.length; i++) {
      var item = st.transition[i];
      if (item.trigger && item.trigger.indexOf(trigger.timeout) != -1) {
        registerTimeout(item, e);
      }
    }
  };

  var registerTimeout = function(tran, e) {
    var t = tran.trigger.split(trigger.timeout)[1], tvar = null;

    tvar = setTimeout(function() {
      advanceState(tran.trigger, e);
    }, t);
    timeoutTrigger.push(tvar);
  };

  var unregisterTimeout = function() {
    if (timeoutTrigger.length > 0) {
      for (var i = 0; i < timeoutTrigger.length; i++) {
        clearTimeout(timeoutTrigger[i]);
      }
      delete timeoutTrigger;
    }
    timeoutTrigger = [];
  };

  /****************************************************
   * 좌표계와 관련된 함수
   ***************************************************/
  var isMoved = function(e) {
    var x = getPageX(e), y = getPageY(e), //XXX multitouch에 대응되지 않음
    dx = currentState.startX - x, dy = currentState.startY - y;

    if (Math.sqrt(dx * dx + dy * dy) >= threshold.move_d) {
      return true;
    }
    return false;
  };

  var getPageX = function(e) {
    var eobj = e;
    if (e.originalEvent.touches && e.originalEvent.touches.length > 0) {
      eobj = e.originalEvent;
    }

    if (istouch && eobj.touches && eobj.touches.length > 0) {
      return eobj.touches[0].pageX;
    } else if (eobj.pageX !== undefined && eobj.pageX !== null) {
      return eobj.pageX;
    } else {
      var idx = currentState.trace.length - 1;
      if (idx < 0) {
        return 0;
      }
      return currentState.trace[idx].x;
    }
  };

  var getPageY = function(e) {
    var eobj = e;
    if (e.originalEvent.touches && e.originalEvent.touches.length > 0) {
      eobj = e.originalEvent;
    }

    if (istouch && eobj.touches && eobj.touches.length > 0) {
      return eobj.touches[0].pageY;
    } else if (eobj.pageY !== undefined && eobj.pageY !== null) {
      return eobj.pageY;
    } else {
      var idx = currentState.trace.length - 1;
      if (idx < 0) {
        return 0;
      }
      return currentState.trace[idx].y;
    }
  };

  var getDistance = function(x1, y1, x2, y2) {
    var dx = x1 - x2, dy = y1 - y2;
    return Math.floor(Math.sqrt(dx * dx + dy * dy));
  };

  var getCurrentSpeed = function(e) {
    var trace = currentState.trace;
    obj = {
      value: 0,
      valueX: 0,
      valueY: 0
    };
    if (trace.length > 2) {
      var tr1 = trace.length - 2, tr2 = trace.length - 1, d, dt;

      //마지막과 차마지막 엘리먼트의 좌표값이 완전 동일할 경우 move후 up일 수 있으므로
      //바로 앞의 trace와 비교하도록 한다.
      if (trace[tr1].x == trace[tr2].x && trace[tr1].y == trace[tr2].y) {
        tr1 = trace.length - 3;
      }
      //500ms이내에 기록된 다른 trace가 있을 경우 기록에 사용한다.
      if (trace[tr1 - 1] && (trace[tr1].time - trace[tr1 - 1].time) < 500) {
        tr1--;
      }

      d = getDistance(trace[tr2].x, trace[tr2].y, trace[tr1].x, trace[tr1].y);
      dt = trace[tr2].time - trace[tr1].time;

      var dx = trace[tr2].x - trace[tr1].x, dy = trace[tr2].y - trace[tr1].y;

      obj.value = Math.floor((d / dt) * 1000);
      obj.valueX = Math.floor((dx / dt) * 1000);
      obj.valueY = Math.floor((dy / dt) * 1000);
    } else {

    }
    $.each(['value', 'valueX', 'valueY'], function(i, v) {
      if (obj[v] === Infinity || obj[v] === NaN) {
        obj[v] = 0;
      }
    });

    return obj;
  };

  var getCurrentMilli = function(t) {
    return new Date().getTime();
  };

  var getCoordinate = function(e) {
    var obj = {}, speed;
    obj.startX = currentState.startX;
    obj.startY = currentState.startY;

    // XXX multitouch에 대응하지 못함.
    obj.pageX = getPageX(e);
    obj.pageY = getPageY(e);

    obj.distance = getDistance(obj.startX, obj.startY, obj.pageX, obj.pageY);
    obj.distanceX = obj.pageX - obj.startX;
    obj.distanceY = obj.pageY - obj.startY;

    speed = getCurrentSpeed(e);
    obj.speed = speed.value;
    obj.speedX = speed.valueX;
    obj.speedY = speed.valueY;

    obj.alignment = '';
    obj.direction = '';

    if (obj.distance < threshold.move_d) {
      obj.alignment = 'stay';
      obj.direction = 'none';
    } else {
      var sin = obj.distanceY / obj.distance;
      if (-0.5 <= sin && sin <= 0.5) {
        //-30~30도, 150~210도
        obj.alignment = 'horizontal';
      } else if (0.866 <= sin || sin <= -0.866) {
        //60~120도, 240~300도
        obj.alignment = 'vertical';
      } else {
        obj.alignment = 'diagonal';
      }

      if (sin <= -0.5 || sin >= 0.5) { //30~150도, 210~330도. down or up
        if (obj.distanceY > 0) {
          obj.direction += 'down';
        } else {
          obj.direction += 'up';
        }
      }
      if (-0.866 <= sin && sin <= 0.866) { //-60~60, 120~240도. right or left
        if (obj.distanceX > 0) {
          obj.direction += 'right';
        } else {
          obj.direction += 'left';
        }
      }
    }

    return obj;
  };

  /****************************************************
   * 이벤트 핸들러 존재여부와 관련된 함수.
   ***************************************************/
  var hasAnyHandler = function(elem, list) {
    var result = false, arr = list || allEvent;
    $.each(arr, function(index, value) {
      if (hasHandler(elem, value)) {
        result = true;
        return false;
      }
    });
    //data-attribute
    var dataevents = ['tap', event.singletap, event.doubletap, event.tripletap,
                      event.longtap];
    $.each(dataevents, function(i,name) {
      if($(elem).attr('data-'+name)) {
        //console.log(name);
        result = true;
      };
    });
    return result;
  };

  var hasHandler = function(elem, eventname) {
    var handler = null;

    if (!elem) {
      return false;
    }

    elem = $(elem)[0];

    if ($._data) {
      handler = $._data($(elem)[0], 'events');
    } else {
      handler = $(elem).data('events');
    }
    //data attribute
    var attr = $(elem).attr('data-' + eventname);
    if(attr) {
      handler = {};
      handler[eventname] = attr;
    }
    if (handler && handler[eventname]) {
      return true;
    }
    return false;
  };

  var getHandlerOwner = function(e, eventname) {
    var owner = e.target, name = (typeof eventname == typeof '') ?
        [eventname] : eventname,
    hasit = hasAnyHandler(owner, name);
    while (!hasit && !!owner.parentElement) {
      owner = owner.parentElement;
      hasit = hasAnyHandler(owner, name);
    }
    if (eventname && !hasit) {
      return null;
    }
    return owner;
  };

  /****************************************************
   * 이벤트의 실제 판별 및 트리거링 로직을 담은 함수
   ***************************************************/
  processor.swipe = function(e) {
    var coor = getCoordinate(e);
    var el = getHandlerOwner(e, [event.swipe, event.swipeleft,
        event.swiperight, event.swipeup, event.swipedown, event.swipemove,
        event.swipecancel]);
    var condition = $(el).data('swipecondition');

    var currentDistance, conditionDistance;
    var currentSpeed, conditionSpeed;

    if (condition && (condition.direction || condition.alignment)) {
      if (condition.alignment &&
          condition.alignment.indexOf(coor.alignment) == -1) {
        currentDistance = -1;
        currentSpeed = -1;
      } else if (condition.alignment &&
                 condition.alignment.indexOf(coor.alignment) != -1) {
        if (coor.alignment == 'vertical') {
          currentDistance = Math.abs(coor.distanceY);
          currentSpeed = Math.abs(coor.speedY);
        } else if (coor.alignment == 'horizontal') {
          currentDistance = Math.abs(coor.distanceX);
          currentSpeed = Math.abs(coor.speedX);
        } else {
          currentDistance = Math.abs(coor.distance);
          currentSpeed = Math.abs(coor.speed);
        }
      } else if (condition.direction &&
          condition.direction.indexOf(coor.direction) != -1) {
        if (coor.direction == 'up') {
          currentDistance = -coor.distanceY;
          currentSpeed = -coor.speedY;
        } else if (coor.direction == 'down') {
          currentDistance = coor.distanceY;
          currentSpeed = coor.speedY;
        } else if (coor.direction == 'left') {
          currentDistance = -coor.distanceX;
          currentSpeed = -coor.speedX;
        } else if (coor.direction == 'right') {
          currentDistance = coor.distanceX;
          currentSpeed = coor.speedX;
        } else {
          currentDistance = -1;
          currentSpeed = -1;
        }
      } else {
        currentDistance = -1;
        currentSpeed = -1;
      }
    } else {
      currentDistance = coor.distance;
      currentSpeed = coor.speed;
    }

    conditionDistance = (condition && condition.distance) ?
        condition.distance : threshold.swipe_d;
    conditionSpeed = (condition && condition.speed) ?
        condition.speed : threshold.swipe_v;

    if (condition && condition.distance && !condition.speed) {
      currentSpeed = -1;
    }
    if (condition && condition.speed && !condition.distance) {
      currentDistance = -1;
    } //조건이 둘다 제시되거나 default를 하는 경우에는 or조건으로 적용하기 위함.

    //distanceX/Y조건 우선.
    if (condition && condition.distanceX) {
      currentDistance = Math.abs(coor.distanceX);
      currentSpeed = -1;
      conditionDistance = Math.abs(condition.distanceX);
      conditionSpeed = 0;
    }
    if (condition && condition.distanceY) {
      currentDistance = Math.abs(coor.distanceY);
      currentSpeed = -1;
      conditionDistance = Math.abs(condition.distanceY);
      conditionSpeed = 0;
    }

    if (currentDistance >= conditionDistance ||
        currentSpeed >= conditionSpeed) {
      $.each(['up', 'down', 'left', 'right'], function(i, v) {
        if (coor.direction == v) {
          triggerEvent(e, currentState.pressedElement,
              'swipe' + coor.direction, coor);
        }
      });
      triggerEvent(e, currentState.pressedElement, event.swipe, coor);
    } else {
      triggerEvent(e, currentState.pressedElement, event.swipecancel, coor);
    }
  };

  processor.ntap = function(e) {
    var ntapevent = [event.tap, event.singletap, event.doubletap,
        event.tripletap], tapcount = currentState.tapcount;
    if (tapcount > 3) {
      tapcount = 3;
    }
    triggerEvent(e, currentState.pressedElement, ntapevent[tapcount]);
    currentState.tapcount = 0;
  };

  //TODO Drag&Drop
  processor.dragstart = function(e) {};
  processor.dragmove = function(e) {};
  processor.dragend = function(e) {};

  /****************************************************
   * State전진을 위한 함수들
   ***************************************************/
  var initCurrentState = function() {
    for(var prop in currentState) {
      if(currentState.hasOwnProperty(prop) &&
          (prop != 'pointer' && prop != 'tapcount')) {
        delete currentState[prop];
      }
    }
    currentState.pressedElement = null;
    currentState.currentElement = null;
    currentState.previousElement = null;
    currentState.startX = null;
    currentState.startY = null;
    currentState.trace = [];
    //currentState.tapcount = 0;
    currentState.needCancel = {};
  };

  var enterState = function(st, e) {
    if (!st) { return false; }
    if (st.entry) { st.entry(e); }
    if (st.doing) { st.doing(e); }
  };

  var hasNullTransition = function() {
    var curr = currentState.pointer;
    for (var i = 0; i < curr.transition.length; i++) {
      if (!curr.transition[i].trigger) {
        return true;
      }
    }
    return false;
  };

  var advanceState = function(inputtrigger, e) {
    do {
      var curr = currentState.pointer, appliedTransition = null;

      currentState.previousElement = currentState.currentElement;
      currentState.currentElement = e.target;

      var tmptrace = {};
      tmptrace.time = getCurrentMilli();
      tmptrace.x = getPageX(e);
      tmptrace.y = getPageY(e);
      if( currentState.trace.length === 0 ||
          (tmptrace.x !== currentState.trace[currentState.trace.length-1].x ||
          tmptrace.y !== currentState.trace[currentState.trace.length-1].y) ) {
        currentState.trace.push(tmptrace);
      }
      //console.log(inputtrigger + ','+currentState.pointer.name+','+currentState.trace.length);
      
      for (var i = 0; i < curr.transition.length; i++) {
        var item = curr.transition[i];

        if (item.trigger != inputtrigger && item.trigger != null) {
          continue;
        }

        if (item.guard == null || (typeof item.guard == typeof function() {
        } && item.guard(e))) {
          appliedTransition = item;
          break;
        }
      }

      if (!appliedTransition) {
        //현재 state에서 적용가능한 state transition이 없는데 down 이 일어났다면
        //state 진행의 에러로 간주하고 최초 state로 이동하도록 한다.
        if (inputtrigger == trigger.down) {
          appliedTransition = {
            to: state.pressedinitial,
            effect: function() {
              triggerCancel(e);
            }
          };
        } else if (inputtrigger.indexOf(trigger.timeout) != -1) {
          //timeout이벤트에 의해서 들어오긴 했는데 가드조건을 통과하지 못할 경우.
          unregisterTimeout();
          registerTimeoutFromState(curr, e);
          return false;
        } else {
          return false;
        }
      }

      unregisterTimeout();
      if (curr.exit) {
        curr.exit(e);
      }

      if ((!!appliedTransition) && appliedTransition.effect) {
        appliedTransition.effect(e);
      }

      currentState.pointer = appliedTransition.to;
      curr = currentState.pointer;

      enterState(curr, e);
      registerTimeoutFromState(curr, e);
      inputtrigger = null;
    } while (hasNullTransition());
  };

  /*************************************************************
   * State정의
   *************************************************************/
  state.idle = createState();
  state.hover = createState();
  state.pressedinitial = createState();
  state.unpressed = createState();
  state.pressedinter = createState();
  state.moving = createState();
  state.endmove = createState();

  //iOS6에서 unpressed handler가 alert창 띄운뒤 승인 누를시 down trigger 발생.
  //이를 막기 위해 unpressed로 진입 전 약간의 딜레이를 준다.
  state.unpressedwait = createState();

  state.idle.entry = function(e) {
    initCurrentState();
    $(document).unbind(eventns);
    $(document).bind(startevent, downHandler);
    $(document).bind(moveevent, moveHandler);
    handleIdleHover();
  };
  var detectDisabled = function(e) {
    var el = getHandlerOwner(e);
    if ($(el).attr('disabled')) {
      return true;
    }
    return false;
  };
  state.idle.transition.push({
    to: state.pressedinitial,
    trigger: trigger.down,
    guard: function(e) {
      return !detectDisabled(e);
    },
    effect: function(e) {
    }
  });
  var handleIdleHover = function(e) {
    if(!e || !e.target) {
      return;
    }
    var hel = getHandlerOwner(e, [event.hoverstart, event.hovering,
                                  event.hoverend]);
    if(hel && !istouch) {
      addTohover(state.idle.transition);
    } else {
      removeTohover(state.idle.transition);
    }
  };
  var addTohover = function(transition) {
    removeTohover(transition);
    transition.push({
      to: state.hover,
      trigger: trigger.timeout + '25',//과도한 overhead 방지.
      guard: function(e) {
        var el = getHandlerOwner(e, [event.hoverstart, event.hovering,
            event.hoverend]);
        if (el) {
          var cond = $(el).data('hovercondition');
          if (cond && cond.delay) {
            var dt = getCurrentMilli() - currentState.lastHoverTime;
            if (dt > cond.delay) {
              return true;
            } else {
              return false;
            }
          }
          return true;
        }
        return false;
      },
      effect: function(e) {
        currentState.pressedElement = getHandlerOwner(e, [event.hoverstart,
            event.hovering, event.hoverend]);
        currentState.currentElement = getHandlerOwner(e);
        triggerEvent(e, currentState.pressedElement, event.hoverstart,
            getCoordinate(e));
      }
    });
  };
  var removeTohover = function(transition) {
    for(var i=transition.length-1; i >=0; i--) {
      if(transition[i].to == state.hover) {
        transition.splice(i,1);
      }
    }
  };
  state.idle.transition.push({
    to: state.idle,
    trigger: trigger.move,
    guard: function(e) {
      var coor = getCoordinate(e);
      currentState.lastHoverTime = getCurrentMilli();
      handleIdleHover(e);
      if (coor.speed > threshold.hover_v || isMovedOverElement(e)) {
        return true;
      }
      return false;
    },
    effect: function(e) {
    }
  });

  //IE 더블클릭 처리 버그로 인해 idle state에서 down 없이 up 만 발생하는 경우,
  //pressedinitial의 entry와 do를 수행하도록 한다.
  state.idle.transition.push({
    to: state.unpressed,
    trigger: trigger.up,
    guard: function(e) {
      //down없이 keyup이 일어나는 경우에 대해서는 처리하지 않음.
      return !detectDisabled(e) && !(e.which == 13 || e.which == 32);
    },
    effect: function(e) {
      state.pressedinitial.entry(e);
      state.pressedinitial.doing(e);
    }
  });

  state.hover.transition.push({
    to: state.hover,
    trigger: trigger.move,
    guard: function(e) {
      var elem = getHandlerOwner(e, [event.hoverstart, event.hovering,
          event.hoverend]);
      if (currentState.pressedElement != elem) {
        return false;
      }
      return true;
    },
    effect: function(e) {
      triggerEvent(e, currentState.pressedElement, event.hovering,
          getCoordinate(e));
    }
  });
  state.hover.transition.push({
    to: state.idle,
    trigger: trigger.move,
    guard: function(e) {
      var elem = getHandlerOwner(e, [event.hoverstart, event.hovering,
          event.hoverend]);
      if (currentState.pressedElement != elem) {
        return true;
      }
      return false;
    },
    effect: function(e) {
      triggerEvent(e, currentState.pressedElement, event.hoverend,
          getCoordinate(e));
    }
  });
  state.hover.transition.push({
    to: state.pressedinitial,
    trigger: trigger.down,
    guard: function(e) {
      return !detectDisabled(e);
    },
    effect: function(e) {
      triggerEvent(e, currentState.pressedElement, event.hoverend,
          getCoordinate(e));
    }
  });

  state.pressedinitial.entry = function(e) {
    //console.log('pressedinitial'+e.type+','+currentState.tapcount);
    initCurrentState();
    currentState.tapcount = 0;
    currentState.pressedElement = getHandlerOwner(e);
    currentState.currentElement = getHandlerOwner(e);
    currentState.startX = getPageX(e);
    currentState.startY = getPageY(e);//XXX multitouch에 대응하지 못함.

    $(document).unbind(moveevent);
    $(document).unbind(endevent);
    $(document).bind(moveevent, moveHandler);
    $(document).bind(endevent, upHandler);
  };
  state.pressedinitial.doing = function(e) {
    triggerEvent(e, currentState.pressedElement, event.pressed,
        getCoordinate(e));
  };
  state.pressedinitial.transition.push({
    to: state.moving,
    trigger: trigger.move,
    guard: function(e) {
      var result = isMoved(e);
      return result;
    },
    effect: function(e) {

    }
  });
  state.pressedinitial.transition.push({
    //to : state.unpressed,
    to: state.unpressedwait,
    trigger: trigger.up,
    guard: function(e) {
      return !detectDisabled(e);
    },
    effect: function(e) {
    }
  });
  state.pressedinitial.transition.push({
    to: state.idle,
    trigger: trigger.timeout + threshold.longtap_t,
    guard: function(e) {
      return hasHandler(currentState.pressedElement, event.longtap);
    },
    effect: function(e) {
      triggerEvent(e, currentState.pressedElement, event.longtap,
          getCoordinate(e));
      triggerEvent(e, currentState.pressedElement, event.unpressed,
          getCoordinate(e));
    }
  });

  var unpressedwait_tr = {
    to: state.unpressed,
    trigger: null,
    guard: null,
    effect: null
  };
  if (istouch) {
    unpressedwait_tr.trigger = trigger.timeout + 50;
  }

  state.unpressedwait.transition.push(unpressedwait_tr);

  state.unpressed.entry = function(e) {
    triggerEvent(e, currentState.pressedElement, event.unpressed,
        getCoordinate(e));
  };
  state.unpressed.doing = function(e) {
    currentState.tapcount++;
    triggerEvent(e, currentState.pressedElement, event.tap);
  };
  state.unpressed.transition.push({
    to: state.idle,
    trigger: trigger.timeout + threshold.ntap_t,
    guard: null,
    effect: function(e) {
      processor.ntap(e);
    }
  });
  state.unpressed.transition.push({
    to: state.pressedinter,
    trigger: trigger.down,
    guard: function(e) {
      return isStayingStill(e) && !isMoved(e);
    },
    effect: null
  });
  state.unpressed.transition.push({
    to: state.pressedinitial,
    trigger: trigger.down,
    guard: function(e) {
      return !isStayingStill(e) || isMoved(e);
    },
    effect: null
  });
  //IE7~9 호환성 문제 - 더블클릭시 mousedown과 click이 생략되는 문제.
  //webbugtrack.blogspot.kr/2008/01/bug-263-beware-of-doubleclick-in-ie.html
  state.unpressed.transition.push({
    to: state.unpressed,
    trigger: trigger.up,
    guard: function(e) {
      //down 없이 keyup 발생시 처리하지 않음. 
      return !(e.which == 13 || e.which == 32);
    },
    effect: function(e) {}
  });

  state.pressedinter.entry = function(e) {
    triggerEvent(e, currentState.pressedElement, event.pressed,
        getCoordinate(e));
  };
  state.pressedinter.transition.push({
    //to : state.unpressed,
    to: state.unpressedwait,
    trigger: trigger.up,
    guard: function(e) {
      return true;
    },
    effect: null
  });
  state.pressedinter.transition.push({
    to: state.pressedinitial,
    trigger: trigger.timeout + threshold.ntap_t,
    guard: null,
    effect: function(e) {
      processor.ntap(e);
    }
  });
  state.pressedinter.transition.push({
    to: state.moving,
    trigger: trigger.move,
    guard: function(e) {
      var result = isMoved(e);
      return result;
    },
    effect: function(e) {
      processor.ntap(e);
    }
  });

  state.moving.doing = function(e) {
    var coor = getCoordinate(e);
    triggerEvent(e, currentState.pressedElement, event.move, coor);
    triggerEvent(e, currentState.pressedElement, event.swipemove, coor);
  };
  state.moving.transition.push({
    to: state.endmove,
    trigger: trigger.up,
    guard: null,
    effect: null
  });
  state.moving.transition.push({
    to: state.moving,
    trigger: trigger.move,
    guard: null,
    effect: null
  });

  state.endmove.doing = function(e) {
    triggerEvent(e, currentState.pressedElement, event.unpressed,
        getCoordinate(e));
    processor.swipe(e);
  };
  state.endmove.transition.push({
    to: state.idle,
    trigger: null,
    guard: null,
    effect: function(e) {}
  });

  for (var name in state) {
    state[name].name = name;
  }

  /**************************************************
   * special event 정의 영역. event parameter등을 처리한다.
   *************************************************/

  var specialEventsRegister = function() {
    var specialswipe = ['', 'left', 'right', 'up', 'down'];
    $.each(specialswipe, function(i, v) {
      $.event.special['swipe' + v] = {
        setup: function(data, namespaces, eventHandle) {
          if (!!data) {
            $(this).data('swipecondition', data);
          }
        },
        teardown: function(namespaces) {
          $(this).removeData('swipecondition');
        }
      };
    });

  if(!istouch) {
    var specialhover = [event.hoverend, event.hovering, event.hoverstart];
    $.each(specialhover, function(i, v) {
      $.event.special[v] = {
        setup: function(data, namespaces, eventHandle) {
          if (!!data) {
            $(this).data('hovercondition', data);
          }
        },
        teardown: function(namespaces) {
          $(this).removeData('hovercondition');
        }
      };
    });
    }
    
    //tap계열 이벤트에 대한 jQuery Plugin 구현
    var taps = ['tap', 'singletap'];
    $.each(taps, function(i,v) {
      $.fn[v] = function(handler) {
        if(handler) {
          return this.bind(v, handler);
        } else {
          //tap과 singletap은 동일. 향후 singletap은 제거한다.
          return this.trigger('tap').trigger('singletap');
        }
      };
    });
    if(useClickFallback) {
        //마우스/키보드 외의 수단에서 인위적으로 .click()을 실행하는 경우에 대한 우회책을 
        //jQuery event extension 으로 구현. 
        var f = ["tap","singletap"];
        $.each(f, function(idx,eventname) {
          $.event.special[eventname] = {
              setup : function(data, eventHandle) {
            	var tagName = String(this.tagName).toUpperCase();
              	if(tagName === "LABEL") return;
              	if(tagName === "INPUT") {
              	  var type = String(this.type).toLowerCase();
              	  if(type === "checkbox") return;
              	  if(type === "radio") return;
              	} 
                var $this = $(this);
                $this.on('click.alopexuitapworkaround'+eventname, function(e) {
                  var tapped = $this.data('alopex-ui-tap-wtapped'+eventname);
                  $this.data('alopex-ui-tap-wtapped'+eventname,null);
                  if(tapped) {
                    return; 
                  }
                  var prevd = false;
                  var stopp = false;
                  
                  var eobj = $.Event(eventname);
                  //eobj.stopPropagation();
                  $this.each(function(){
                    $(this).triggerHandler(eobj,[true]);
                  })
                  prevd = prevd || eobj.isDefaultPrevented();
                  //stopp = stopp || eobj.isPropagationStopped();
                  
                  $this.data('alopex-ui-tap-wtapped-keyup'+eventname,true);
                });
              },
              teardown : function() {
                var $this = $(this);
                $this.off('.alopexuitapworkaround'+eventname);
              },
              _default : function(event, data) {
                $(this).data('alopex-ui-tap-wtapped-keyup'+eventname,null);
              },
              handle : function(event,noinc) {
                var $this = $(this);
                var handleObj = event.handleObj;
                var targetData = jQuery.data( event.target );
                var ret = null;
                event.type = handleObj.origType;
                if(!(event.origType === "keyup" && $this.data('alopex-ui-tap-wtapped-keyup'+eventname))) {
                  ret = handleObj.handler.apply(this, arguments);
                  if(noinc !== true) {
                    $this.data('alopex-ui-tap-wtapped'+eventname, true);
                  }
                }
                event.type = handleObj.type;
                return ret;
              }
          };
        });
        
     }
    var tapevents = [event.singletap, event.doubletap, event.tripletap,
                     event.longtap];
    $.each(tapevents, function(i,v) {
      $.fn[v] = function(handler) {
        return handler ? this.bind(v, handler) :
          this.trigger(v);
      };
    });
  };

  //drag & drop 구현.
  // http://api.jquery.com/category/events/event-object/
  //$.event.props.push('dataTransfer');

  /**************************************************
   * 이벤트모듈 초기화
   *************************************************/
  var unbindme = function() {
    $(document).unbind(eventns);
    $(document).unbind(startevent);
    $(document).unbind(moveevent);
    $(document).unbind(endevent);
  };

  function init() {
    unbindme();
    initCurrentState();
    currentState.tapcount = 0;
    currentState.pointer = state.idle;
    enterState(currentState.pointer, {});
  }

  specialEventsRegister();
  init();
})(jQuery);
